{
    "docs": [
        {
            "location": "/", 
            "text": "PyQuran: The Python package for Quranic Analysis\n\n\nPyQuran is a package which provides tools for \nQuranic Analysis\n.\n\n\nIt is still a small package which needs a lot of your effort. We believe that it\nis a seed of a fundamental general package for\ncomputations on \nQuran\n with Python, even at the most basic level which simply retrieving Quran text.\n\n\nBefore Islam\n, Arabic letters  were without  dots\u2014\n\nrasm\n, which resulted in ambiguty, two or three\nletters had the same rasm/form/shape/look. \n\n\nMuslims have decided to remove this ambiguity by adding\ndots above or below each letter of the ones which share the same rasm. Now each letter has a unique form. By the way,\noriginally, \nQuran\n was written without dots on the letters.\n\n\nTo enable you to use both modern system or other, we introduce \nalphabetical systems\n,\nIt is a dynamic construction of letters\u2014\n\nAlphabetical Systems\n.\n\n\nCurrent Features\n\n\n\n\nfetch chapters and verses.\n\n\nsearch Quran by text tokens and by diacritics patterns.\n\n\nbuckwalter transliteration, back and forth\n\n\nMultiple \nalphabetical systems\n, \nfor more details see the \nPyQuran Wiki\n\n\n\n\nInstall\n\n\n\n\nFrom \nPyPI\n: \n$ pip3 install pyquran\n\n\nFrom Source: \n$ python3 setup.py install\n\n\n\n\nDependencies\n\n\n\n\nnumpy\n\n\npyarabic\n\n\n\n\nQuran Corpus\n\n\nWe use \ntanzil\n Quran Corpus (\nUthmani Text\n), it is in \nUTF-8\n encoding. You\ncan find all unique characters of Uthmanic Corpus\n\nhere\n.\n\n\nThere are \nspecial recitation symbols\n \u0645\u0635\u0637\u0644\u062d\u0627\u062a \u0627\u0644\u0636\u0628\u0637 in the \nUthmani Text\n, they are a guide for the reciter\nto know the right positions to pause and the rules of tajweed.\nWe provide an interface to filter those symbols, \nonly the fly while fetching from the corpus\n,\nwe \nDO NOT\n change the corpus, NEVER.\n\n\nFor the full details about filtering \nspecial recitation symbols\n \u0645\u0635\u0637\u0644\u062d\u0627\u062a\n\u0627\u0644\u0636\u0628\u0637.\n\n\nContributing\n\n\nTo contribute and maintain \nPyQuran\n, Please read  \nCONTRIBUTING.md\n.\n\n\nSee also \nHow to contribute to PyQuran\n.\n\n\nCiting\n\n\nnot_completed_ (need to disscuss it with the prof.)\nCite \nPyQuran\n as the following \nBibTeX\n entry.\n\n\n@MISC {PyQuran2018,\nauthor             = \nWaleed A. Yousef\n,\ntitle              = \nPyQuran\n,\nhowpublished       = \nhttps://github.com/TahaMagdy/PyQuran\n,\nmonth              = \nfeb\n,\nyear               = \n2018\n\n}\n\n\n\n\nCommunication\n\n\n\u0640not_completed_\n\n\nLicence\n\n\nnot_completed_ (need to discuss it with the prof.)", 
            "title": "Home"
        }, 
        {
            "location": "/#pyquran-the-python-package-for-quranic-analysis", 
            "text": "PyQuran is a package which provides tools for  Quranic Analysis .  It is still a small package which needs a lot of your effort. We believe that it\nis a seed of a fundamental general package for\ncomputations on  Quran  with Python, even at the most basic level which simply retrieving Quran text.  Before Islam , Arabic letters  were without  dots\u2014 rasm , which resulted in ambiguty, two or three\nletters had the same rasm/form/shape/look.   Muslims have decided to remove this ambiguity by adding\ndots above or below each letter of the ones which share the same rasm. Now each letter has a unique form. By the way,\noriginally,  Quran  was written without dots on the letters.  To enable you to use both modern system or other, we introduce  alphabetical systems ,\nIt is a dynamic construction of letters\u2014 Alphabetical Systems .", 
            "title": "PyQuran: The Python package for Quranic Analysis"
        }, 
        {
            "location": "/#current-features", 
            "text": "fetch chapters and verses.  search Quran by text tokens and by diacritics patterns.  buckwalter transliteration, back and forth  Multiple  alphabetical systems ,  for more details see the  PyQuran Wiki", 
            "title": "Current Features"
        }, 
        {
            "location": "/#install", 
            "text": "From  PyPI :  $ pip3 install pyquran  From Source:  $ python3 setup.py install", 
            "title": "Install"
        }, 
        {
            "location": "/#dependencies", 
            "text": "numpy  pyarabic", 
            "title": "Dependencies"
        }, 
        {
            "location": "/#quran-corpus", 
            "text": "We use  tanzil  Quran Corpus ( Uthmani Text ), it is in  UTF-8  encoding. You\ncan find all unique characters of Uthmanic Corpus here .  There are  special recitation symbols  \u0645\u0635\u0637\u0644\u062d\u0627\u062a \u0627\u0644\u0636\u0628\u0637 in the  Uthmani Text , they are a guide for the reciter\nto know the right positions to pause and the rules of tajweed.\nWe provide an interface to filter those symbols,  only the fly while fetching from the corpus ,\nwe  DO NOT  change the corpus, NEVER.  For the full details about filtering  special recitation symbols  \u0645\u0635\u0637\u0644\u062d\u0627\u062a\n\u0627\u0644\u0636\u0628\u0637.", 
            "title": "Quran Corpus"
        }, 
        {
            "location": "/#contributing", 
            "text": "To contribute and maintain  PyQuran , Please read   CONTRIBUTING.md .  See also  How to contribute to PyQuran .", 
            "title": "Contributing"
        }, 
        {
            "location": "/#citing", 
            "text": "not_completed_ (need to disscuss it with the prof.)\nCite  PyQuran  as the following  BibTeX  entry.  @MISC {PyQuran2018,\nauthor             =  Waleed A. Yousef ,\ntitle              =  PyQuran ,\nhowpublished       =  https://github.com/TahaMagdy/PyQuran ,\nmonth              =  feb ,\nyear               =  2018 \n}", 
            "title": "Citing"
        }, 
        {
            "location": "/#communication", 
            "text": "\u0640not_completed_", 
            "title": "Communication"
        }, 
        {
            "location": "/#licence", 
            "text": "not_completed_ (need to discuss it with the prof.)", 
            "title": "Licence"
        }, 
        {
            "location": "/quran_tools/", 
            "text": "Retrieving Quran\n\n\nPyQuran is a set of functions and variables.\n\n\nimport pyquran as q\n\n\n\n\nget_sura\n\n\nget_sura(sura_number, with_tashkeel=False)\n\n\n\n\nReturns a list of verses, where verses are nothing but strings.\n\n\nArguments\n\n\n\n\nsura_number\n:   (int)the ordered number of sura in The Mushaf, starting from 1.\n\n\nwith_tashkeel\n: (bool) to return verses with diacritics to not.\n\n\n\n\nExample\n\n\nq.get_sura(108, True)\nOut: ['\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e', '\u0641\u064e\u0635\u064e\u0644\u0651\u0650 \u0644\u0650\u0631\u064e\u0628\u0651\u0650\u0643\u064e \u0648\u064e\u0627\u0646\u0652\u062d\u064e\u0631\u0652', '\u0625\u0650\u0646\u0651\u064e \u0634\u064e\u0627\u0646\u0650\u0626\u064e\u0643\u064e \u0647\u064f\u0648\u064e \u0627\u0644\u0652\u0623\u064e\u0628\u0652\u062a\u064e\u0631\u064f']\n\n\n\n\n\n\nfetch_aya\n\n\nq.fetch_aya(sura_number, aya_number)\n\n\n\n\nReturns a verse.\n\n\nArguments\n\n\n\n\nsura_number\n: (int) the ordered number of sura in The Mus'haf.\n\n\naya_number\n:  (int) the ordered number of aya in The Mus'haf.\n\n\n\n\nExample\n\n\nq.fetch_aya(1, 2)\nOut: '\u0627\u0644\u062d\u0645\u062f \u0644\u0644\u0647 \u0631\u0628 \u0627\u0644\u0639\u0644\u0645\u064a\u0646'\n\n\n\n\n\n\nget_sura_name\n\n\nq.get_sura_name(suraNumber=None)\n\n\n\n\nReturns the Arabic name of a Sura.\n\n\nArguments\n\n\n\n\nsuraNumber\n:   (int) the ordered number of sura in The Mushaf, starting from 1.\n\n\n\n\nExample\n\n\nq.get_sura_name(2)\nOut: '\u0627\u0644\u0628\u0642\u0631\u0629'\n\n\n\n\n\n\nget_sura_number\n\n\nq.get_sura_number(suraName)\n\n\n\n\nReturns the Arabic name of a Sura.\n\n\nArguments\n\n\n\n\nsuraName\n:  (str) The Arabic Sura name.\n\n\n\n\nExample\n\n\npq.get_sura_number('\u0627\u0644\u0645\u0644\u0643')\n\n 67", 
            "title": "Basic Tools for Quran"
        }, 
        {
            "location": "/quran_tools/#retrieving-quran", 
            "text": "PyQuran is a set of functions and variables.  import pyquran as q", 
            "title": "Retrieving Quran"
        }, 
        {
            "location": "/quran_tools/#get_sura", 
            "text": "get_sura(sura_number, with_tashkeel=False)  Returns a list of verses, where verses are nothing but strings.  Arguments   sura_number :   (int)the ordered number of sura in The Mushaf, starting from 1.  with_tashkeel : (bool) to return verses with diacritics to not.   Example  q.get_sura(108, True)\nOut: ['\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e', '\u0641\u064e\u0635\u064e\u0644\u0651\u0650 \u0644\u0650\u0631\u064e\u0628\u0651\u0650\u0643\u064e \u0648\u064e\u0627\u0646\u0652\u062d\u064e\u0631\u0652', '\u0625\u0650\u0646\u0651\u064e \u0634\u064e\u0627\u0646\u0650\u0626\u064e\u0643\u064e \u0647\u064f\u0648\u064e \u0627\u0644\u0652\u0623\u064e\u0628\u0652\u062a\u064e\u0631\u064f']", 
            "title": "get_sura"
        }, 
        {
            "location": "/quran_tools/#fetch_aya", 
            "text": "q.fetch_aya(sura_number, aya_number)  Returns a verse.  Arguments   sura_number : (int) the ordered number of sura in The Mus'haf.  aya_number :  (int) the ordered number of aya in The Mus'haf.   Example  q.fetch_aya(1, 2)\nOut: '\u0627\u0644\u062d\u0645\u062f \u0644\u0644\u0647 \u0631\u0628 \u0627\u0644\u0639\u0644\u0645\u064a\u0646'", 
            "title": "fetch_aya"
        }, 
        {
            "location": "/quran_tools/#get_sura_name", 
            "text": "q.get_sura_name(suraNumber=None)  Returns the Arabic name of a Sura.  Arguments   suraNumber :   (int) the ordered number of sura in The Mushaf, starting from 1.   Example  q.get_sura_name(2)\nOut: '\u0627\u0644\u0628\u0642\u0631\u0629'", 
            "title": "get_sura_name"
        }, 
        {
            "location": "/quran_tools/#get_sura_number", 
            "text": "q.get_sura_number(suraName)  Returns the Arabic name of a Sura.  Arguments   suraName :  (str) The Arabic Sura name.   Example  pq.get_sura_number('\u0627\u0644\u0645\u0644\u0643')  67", 
            "title": "get_sura_number"
        }, 
        {
            "location": "/arabic_tools/", 
            "text": "Alphabets\n\n\nWe use \nPyArabic\n constants which\nrepresents letters, instead of writting Arabic in the code.\n\n\nhamza            = u'\\u0621'\nalef_mad         = u'\\u0622'\nalef_hamza_above = u'\\u0623'\nwaw_hamza        = u'\\u0624'\nalef_hamza_below = u'\\u0625'\nyeh_hamza        = u'\\u0626'\nalef             = u'\\u0627'\nbeh              = u'\\u0628'\nteh_marbuta      = u'\\u0629'\nteh              = u'\\u062a'\ntheh             = u'\\u062b'\njeem             = u'\\u062c'\nhah              = u'\\u062d'\nkhah             = u'\\u062e'\ndal              = u'\\u062f'\nthal             = u'\\u0630'\nreh              = u'\\u0631'\nzain             = u'\\u0632'\nseen             = u'\\u0633'\nsheen            = u'\\u0634'\nsad              = u'\\u0635'\ndad              = u'\\u0636'\ntah              = u'\\u0637'\nzah              = u'\\u0638'\nain              = u'\\u0639'\nghain            = u'\\u063a'\nfeh              = u'\\u0641'\nqaf              = u'\\u0642'\nkaf              = u'\\u0643'\nlam              = u'\\u0644'\nmeem             = u'\\u0645'\nnoon             = u'\\u0646'\nheh              = u'\\u0647'\nwaw              = u'\\u0648'\nalef_maksura     = u'\\u0649'\nyeh              = u'\\u064a'\nmadda_above      = u'\\u0653'\nhamza_above      = u'\\u0654'\nhamza_below      = u'\\u0655'\nalef_wasl        = u'\\u0671'\n\n\n\n\nAlphabetical Systems\n\n\nWe define \nalphabetical system\n as a dynamic construction of letters in which\nyou can treat a group of letters one letter. The default alphabet is a special\ncase of the Alphabetical System where each letter is treated as one letter.\n\n\nPredefined systems\n are stored in \nsystems\n object.\n\n\n\n\ndefault.\n\n\nwithout dots system.\n\n\nhamazat.\n\n\n\n\nExample:\n\n\nq.systems.withoutDots\nOut: \n[['\u0628', '\u062a', '\u062b', '\u0646'],\n ['\u062d', '\u062e', '\u062c'],\n ['\u062f', '\u0630'],\n ['\u0631', '\u0632'],\n ['\u0633', '\u0634'],\n ['\u0635', '\u0636'],\n ['\u0637', '\u0638'],\n ['\u0639', '\u063a'],\n ['\u0641', '\u0642']]\n\n\n\n\nConstruct a user-defined system\n:\n\n\nsystem = [[alef_hamza_above, alef],[beh, teh]]\n\n\n\n\nThe previous line of code means \"Treat \nalef_hamza_above\n and \nalef\n\nas the same one latter, also treat \nbeh\n and \nteh\n as one letter as well\"\n\n\nAnd then, a system can be applied to some text analysis functions like counting,\nfiltering, etc.\n\n\ncheck_system\n\n\ncheck_system(system, index=None)\n\n\n\n\nReturns the alphabet including treated-as-one letters. If you pass the index as\nthe second optional arguement, it returns the letter of the that index only, not the\nhole alphabet.\n\n\nArguments\n\n\n\n\nsystem\n:  a list of letters, where each letter to be treated as one letter\n  are in one sublist. see \nAlphabetical Systems\n\n\nindex\n: (int) is a index of a letter in the new system.\n\n\n\n\nExample\n\n\nThis prints each letter as one element in a new alphabet list, as you can see the\ntwo letters \nalef\n and \nbeh\n are considered one letter.\n\n\nq.check_system([['alef', 'beh']])\nOut: \n[['\u0621'],\n ['\u0622'],\n ['\u0623', '\u0628'],\n ['\u0624'],\n ['\u0625'],\n ['\u0626'],\n ['\u0627'],\n ['\u0629'],\n ['\u062a'],\n ['\u062b'],\n ['\u062c'],\n ['\u062d'],\n ['\u062e'],\n ['\u062f'],\n ['\u0630'],\n ['\u0631'],\n ['\u0632'],\n ['\u0633'],\n ['\u0634'],\n ['\u0635'],\n ['\u0636'],\n ['\u0637'],\n ['\u0638'],\n ['\u0639'],\n ['\u063a'],\n ['\u0641'],\n ['\u0642'],\n ['\u0643'],\n ['\u0644'],\n ['\u0645'],\n ['\u0646'],\n ['\u0647'],\n ['\u0648'],\n ['\u0649'],\n ['\u064a']]\n\n\n\n\n\n\n\nbuckwalter_transliteration\n\n\nBack and forth bauckwalter-arabic transliteration.\n\n\nNOTE\n: Revise \nBuckwalter\n\n\nq.buckwalter_transliteration('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\nOut: \nin~aA \naEoTayonaka Alokawovara\n\n\n\n\nseparate_token_with_diacritics\n\n\nseparate_token_with_diacritics(sentence)\n\n\n\n\nGrouping each letter with its diacritics. \n\n\nArgument\n\n\n\n\nsentence\n: (str)\n\n\n\n\nExample\n\n\nq.separate_token_with_dicrites('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\nOut: ['\u0625\u0650', '\u0646\u0651\u064e', '\u0627', ' ', '\u0623\u064e', '\u0639\u0652', '\u0637\u064e', '\u064a\u0652', '\u0646\u064e', '\u0643\u064e', ' ', '\u0627', '\u0644\u0652', '\u0643\u064e', '\u0648\u0652', '\u062b\u064e', '\u0631\u064e']\n\n\n\n\nunpack_alef_mad\n\n\nunpack_alef_mad\n\n\nunpack_alef_mad(sentance)\n\n\n\n\nFactors alef_mad in a sentance into alef_hamza and alef and returns the sentance.\n\n\nArgument\n\n\n\n\nsentance\n: (str)\n\n\n\n\nExample\n\n\nq.unpack_alef_mad('\u0622')\nOut: '\u0623\u0652\u0623\u064e'", 
            "title": "Arabic Tools"
        }, 
        {
            "location": "/arabic_tools/#alphabets", 
            "text": "We use  PyArabic  constants which\nrepresents letters, instead of writting Arabic in the code.  hamza            = u'\\u0621'\nalef_mad         = u'\\u0622'\nalef_hamza_above = u'\\u0623'\nwaw_hamza        = u'\\u0624'\nalef_hamza_below = u'\\u0625'\nyeh_hamza        = u'\\u0626'\nalef             = u'\\u0627'\nbeh              = u'\\u0628'\nteh_marbuta      = u'\\u0629'\nteh              = u'\\u062a'\ntheh             = u'\\u062b'\njeem             = u'\\u062c'\nhah              = u'\\u062d'\nkhah             = u'\\u062e'\ndal              = u'\\u062f'\nthal             = u'\\u0630'\nreh              = u'\\u0631'\nzain             = u'\\u0632'\nseen             = u'\\u0633'\nsheen            = u'\\u0634'\nsad              = u'\\u0635'\ndad              = u'\\u0636'\ntah              = u'\\u0637'\nzah              = u'\\u0638'\nain              = u'\\u0639'\nghain            = u'\\u063a'\nfeh              = u'\\u0641'\nqaf              = u'\\u0642'\nkaf              = u'\\u0643'\nlam              = u'\\u0644'\nmeem             = u'\\u0645'\nnoon             = u'\\u0646'\nheh              = u'\\u0647'\nwaw              = u'\\u0648'\nalef_maksura     = u'\\u0649'\nyeh              = u'\\u064a'\nmadda_above      = u'\\u0653'\nhamza_above      = u'\\u0654'\nhamza_below      = u'\\u0655'\nalef_wasl        = u'\\u0671'", 
            "title": "Alphabets"
        }, 
        {
            "location": "/arabic_tools/#alphabetical-systems", 
            "text": "We define  alphabetical system  as a dynamic construction of letters in which\nyou can treat a group of letters one letter. The default alphabet is a special\ncase of the Alphabetical System where each letter is treated as one letter.  Predefined systems  are stored in  systems  object.   default.  without dots system.  hamazat.   Example:  q.systems.withoutDots\nOut: \n[['\u0628', '\u062a', '\u062b', '\u0646'],\n ['\u062d', '\u062e', '\u062c'],\n ['\u062f', '\u0630'],\n ['\u0631', '\u0632'],\n ['\u0633', '\u0634'],\n ['\u0635', '\u0636'],\n ['\u0637', '\u0638'],\n ['\u0639', '\u063a'],\n ['\u0641', '\u0642']]  Construct a user-defined system :  system = [[alef_hamza_above, alef],[beh, teh]]  The previous line of code means \"Treat  alef_hamza_above  and  alef \nas the same one latter, also treat  beh  and  teh  as one letter as well\"  And then, a system can be applied to some text analysis functions like counting,\nfiltering, etc.", 
            "title": "Alphabetical Systems"
        }, 
        {
            "location": "/arabic_tools/#check_system", 
            "text": "check_system(system, index=None)  Returns the alphabet including treated-as-one letters. If you pass the index as\nthe second optional arguement, it returns the letter of the that index only, not the\nhole alphabet.  Arguments   system :  a list of letters, where each letter to be treated as one letter\n  are in one sublist. see  Alphabetical Systems  index : (int) is a index of a letter in the new system.   Example  This prints each letter as one element in a new alphabet list, as you can see the\ntwo letters  alef  and  beh  are considered one letter.  q.check_system([['alef', 'beh']])\nOut: \n[['\u0621'],\n ['\u0622'],\n ['\u0623', '\u0628'],\n ['\u0624'],\n ['\u0625'],\n ['\u0626'],\n ['\u0627'],\n ['\u0629'],\n ['\u062a'],\n ['\u062b'],\n ['\u062c'],\n ['\u062d'],\n ['\u062e'],\n ['\u062f'],\n ['\u0630'],\n ['\u0631'],\n ['\u0632'],\n ['\u0633'],\n ['\u0634'],\n ['\u0635'],\n ['\u0636'],\n ['\u0637'],\n ['\u0638'],\n ['\u0639'],\n ['\u063a'],\n ['\u0641'],\n ['\u0642'],\n ['\u0643'],\n ['\u0644'],\n ['\u0645'],\n ['\u0646'],\n ['\u0647'],\n ['\u0648'],\n ['\u0649'],\n ['\u064a']]", 
            "title": "check_system"
        }, 
        {
            "location": "/arabic_tools/#buckwalter_transliteration", 
            "text": "Back and forth bauckwalter-arabic transliteration.  NOTE : Revise  Buckwalter  q.buckwalter_transliteration('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\nOut:  in~aA  aEoTayonaka Alokawovara", 
            "title": "buckwalter_transliteration"
        }, 
        {
            "location": "/arabic_tools/#separate_token_with_diacritics", 
            "text": "separate_token_with_diacritics(sentence)  Grouping each letter with its diacritics.   Argument   sentence : (str)   Example  q.separate_token_with_dicrites('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\nOut: ['\u0625\u0650', '\u0646\u0651\u064e', '\u0627', ' ', '\u0623\u064e', '\u0639\u0652', '\u0637\u064e', '\u064a\u0652', '\u0646\u064e', '\u0643\u064e', ' ', '\u0627', '\u0644\u0652', '\u0643\u064e', '\u0648\u0652', '\u062b\u064e', '\u0631\u064e']", 
            "title": "separate_token_with_diacritics"
        }, 
        {
            "location": "/arabic_tools/#unpack_alef_mad", 
            "text": "unpack_alef_mad  unpack_alef_mad(sentance)  Factors alef_mad in a sentance into alef_hamza and alef and returns the sentance.  Argument   sentance : (str)   Example  q.unpack_alef_mad('\u0622')\nOut: '\u0623\u0652\u0623\u064e'", 
            "title": "unpack_alef_mad"
        }, 
        {
            "location": "/analysis_tools/", 
            "text": "count_shape\n\n\ncount_shape(text, system=None)\n\n\n\n\ncounts all the letters given a system.\n\n\nArguments\n\n\n\n\ntext\n:  (str) or [str]\n\n\nsystem\n:  (system), see \nAlphabetical System\n.\n\n\n\n\nReturn\n\n\nA \nnumpy\n \n\n \nmatrix, where \n is the number of ayat and \n is the number of letters in \nsystem\n.\n\n\nExample\n\n\nuser_defined_system = [[beh, teh, theh], [jeem, hah, khah]]\nAlNsr = get_sura(110)\nq.count_shape(AlNsr, user_defined_system)\n\nOut:\n[[1, 0, 0, 0, 1, 0, 4, 1, 0, 2, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 1, 1, 1, 0, 0],\n [0, 0, 2, 0, 0, 0, 5, 1, 0, 2, 2, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 4, 0, 3, 1, 3, 1, 3],\n [0, 0, 0, 0, 1, 0, 4, 6, 0, 2, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 1, 2, 0, 2, 0, 1, 2, 2, 2, 0, 0]]\n\n\n\n\n\n\n\ncount_token\n\n\ncount_token(text)\n\n\n\n\nCounts the number of words of a Sura.\n\n\nArguments\n\n\n\n\ntext\n:  it can be sura [str] or (str)\n\n\n\n\nExample\n\n\nAlKwther = get_sura(108)\nq.count_token(AlKwther)\n\nOut: 10\n\n\n\n\n\n\nfrequency_of_character\n\n\nfrequency_of_character(characters, verse=None, chapterNum=0, verseNum=0, with_tashkeel=False):\n\n\n\n\ncomputes the letters freqency in an Aya.\n\n\nArguments\n\n\n\n\nverse\n: (str) if you passed a verse, counts will be applied to this verse only.\n\n\nchapterNum\n: (int) if you passed it, counts will be applied to this Sura.\n\n\nverseNum\n (int):\n\n\nif you passed it only, counts will be applied to the same verse number in all quran.\n\n\nif passed you passed it with \nchapterNum\n, it will applied to verseNum in sura number  \nchapterNum\n.\n\n\n\n\n\n\nwith_tashkeel\n (bool):\n\n\nif \nTrue\n, counts will be applied to Quran with diacritics.\n\n\nif \nFalse\n counts will be applied to Quran without diacritics.\n\n\n\n\n\n\nIf you don't pass any optional arguments, counts will be applied to the hole Quran.\n\n\n\n\nExample\n\n\nq.frequency_of_character([alef, beh], 114, 1)\nOut: {'\u0627': 2, '\u0628': 2}\n\n\n\n\n\n\ngenerate_frequancy_dictionary\n\n\ngenerate_frequency_dictionary(suraNumber=None)\n\n\n\n\ncounts the frequency of words in a Sura\n\n\nArguments\n\n\n\n\nsuraNumber\n:  (int)\n\n\nIf you don't pass the suraNumber, it will compute the words frequency in the hole Quran.\n\n\n\n\nExample\n\n\nq.generate_frequency_dictionary(108)\nOut: \n{'\u0623\u0639\u0637\u064a\u0646\u0643': 1,\n '\u0625\u0646': 1,\n '\u0625\u0646\u0627': 1,\n '\u0627\u0644\u0623\u0628\u062a\u0631': 1,\n '\u0627\u0644\u0643\u0648\u062b\u0631': 1,\n '\u0634\u0627\u0646\u0626\u0643': 1,\n '\u0641\u0635\u0644': 1,\n '\u0644\u0631\u0628\u0643': 1,\n '\u0647\u0648': 1,\n '\u0648\u0627\u0646\u062d\u0631': 1}\n\n\n\n\n\n\nsort_dictionary_by_similarity\n\n\nsort_dictionary_by_similarity(frequency_dictionary, threshold=0.8)\n\n\n\n\n@Umar, PUT THE REFERENCE !!\n\n\nArguments\n\n\n\n\nfrequency_dictionary\n:  which is generated by \ngenerate_frequency_dictionary\n\n\nthreshold\n: (int) @Umar Define the similarity according to the library you\n  have used!!\n\n\n\n\nExample\n\n\nq.sort_dictionary_by_similarity(dictionaryFrequency)\n\nOut: {'\u0627\u0644\u0646\u0627\u0633': 4, '\u0627\u0644\u062e\u0646\u0627\u0633': 1, '\u0648\u0627\u0644\u0646\u0627\u0633': 1, '\u0645\u0646': 2, '\u0642\u0644': 1, '\u0623\u0639\u0648\u0630': 1, '\u0628\u0631\u0628': 1, '\u0645\u0644\u0643': 1, '\u0625\u0644\u0647': 1, '\u0634\u0631': 1, '\u0627\u0644\u0648\u0633\u0648\u0627\u0633': 1, '\u0627\u0644\u0630\u0649': 1, '\u064a\u0648\u0633\u0648\u0633': 1, '\u0641\u0649': 1, '\u0635\u062f\u0648\u0631': 1, '\u0627\u0644\u062c\u0646\u0629': 1}\n\n\n\n\n\n\ngenerate_latex_table\n\n\ngenerate_latex_table(dictionary, filename, location=\n.\n)\n\n\n\n\ngenerates LaTeX code of frequency table. Returns \nTrue\n in case of success,\n\nFalse\n otherwise.\n\n\nArguments\n\n\n\n\ndictionary\n:  which is generated by \ngenerate_frequency_dictionary\n\n\nfilename\n: the output latex file name.\n\n\nlocation\n: (str) path.\n\n\n\n\nExample\n\n\nq.generate_latex_table(dictionaryFrequency,'any_file_name')\nOut: True\n\n\n\n\n\n\nsearch_string_with_tashkeel\n\n\nsearch_string_with_tashkeel(sentence, tashkeel_pattern)\n\n\n\n\nsearch text with diacritics pattern.\n\n\nArguments\n\n\n\n\nsentence\n: (str)\n\n\ntashkeel_pattern\n: ([str]) a list of diacritics pattern.\n\n\n\n\nReturn\n\n\nA list of matching tokens in the text [(start_index, end_index)].\n\n\nNOTE\n: Start index is inclusive and End index is exclusive.\n\n\nExample\n\n\nsentence = '\u0635\u0650\u0641\u0652 \u0630\u064e\u0627\u0652 \u062b\u064e\u0646\u064e\u0627\u0652 \u0643\u064e\u0645\u0652 \u062c\u064e\u0627\u0652\u062f\u064e \u0634\u064e\u062e\u0652\u0635\u064c'\ntashkeel_pattern = fatha + sukun\nq.search_string_with_tashkeel(sentence,tashkeel_pattern)\nOut: [(3, 5), (7, 9), (10, 12), (13, 15), (17, 19)]\n\n\n\n\n\n\nsearch_sequence\n\n\nsearch_sequence(sequancesList, verse=None, chapterNum=0, verseNum=0, mode=3)\n\n\n\n\n@Umar; Revise this.\n- take list of sequances and return matched sequance, it search in verse ot chapter or All Quran,\n    - it return for every match :\n         - matched sequance \n         - chapter number of occurrence\n         - token number if word and 0 if sentence\n\n\n- Note :\n     - if found verse != None it will use it en search .    \n     - if no verse and found chapterNum and verseNum it will use this verse and use it to search.\n     - if no verse and no verseNum and found chapterNum it will search in chapter.\n     - if no verse and no chapterNum and no verseNum it will search in All Quran.\n\n- it has many modes:\n    1. search with decorated sequance (with tashkeel), and return matched sequance with decorates (with tashkil).\n    2. search without decorated sequance (without tashkeel), and return matched sequance without decorates (without tashkil).\n    3. search without decorated sequance (without tashkeel), and return matched sequance with decorates (with tashkil).\n\n\n- optional opptions: \n    - **verse** (str): if passed, it will applied to this string only \n    - **chapterNum** (int) : if passed only, it will applied to this chapter only.\n    - **verseNum** (int) :\n        - if passed only, it will applied to **verseNum** for **all Chapters**.\n        - if passed with **chapterNum**, it will applied to verseNum for **chapterNum**.\n    - **with_tashkeel** (bool):\n        - if **True** applied to Quran **with** Tashkieel.\n        - if **False** applied to Quran **without** Tashkieel.\n        - mode (int): this mode that you need to use and default mode 3\n\n- Note : if don't pass any  **optional opptions** it will applied to all **Quran**.\n- Returns: dict() : key is sequances and value is a list of matched_sequance and their positions\n\n\n\nq.search_sequence(['\u0642\u0644 \u0623\u0639\u0648\u0630 \u0628\u0631\u0628'])\nOut: {'\u0642\u0644 \u0623\u0639\u0648\u0630 \u0628\u0631\u0628': [('\u0642\u064f\u0644\u0652 \u0623\u064e\u0639\u064f\u0648\u0630\u064f \u0628\u0650\u0631\u064e\u0628\u0651\u0650', 0, 1, 113), ('\u0642\u064f\u0644\u0652 \u0623\u064e\u0639\u064f\u0648\u0630\u064f \u0628\u0650\u0631\u064e\u0628\u0651\u0650', 0, 1, 114)]}\n\n\n\n\nsearch_with_pattern\n\n\nsearch_with_pattern(pattern,sentence=None,verseNum=None,chapterNum=None,threshold=1)\n\n\n\n\n\n\n\n\nthis function use to search in 0's,1's pattern and return matched words from sentence pattern dependent on the    threshold, it takes a \npatter\n that you need to looking for , and \nsentence (optional)\n (sentence where will   search), \nchapterNum (opetional)\n and \nverseNum (opetional)\n and return list of matched words and sentences. \n\n\n\n\n\n\nCases: \n\n\n\n\nif pass sentece only or with another args \n   it will search in sentece only.\n\n\nif not passed sentence and passed verseNum and chapterNum,\n   it will search in this verseNum that exist in chapterNum only.\n\n\nif not passed sentence,verseNum and passed chapterNum only,\n   it will search in this specific chapter only\n\n\n\n\n\n\n\n\nNote : it's takes time dependent on your threshold and size of chapter, so it's not support to search on All-Quran becouse it take very long time more than 11 min.\n\n\n\n\n\n\n\n\n\n\nq.search_with_pattern(pattern=\n01111\n,chapterNum=1,threshold=0.9)\nOut: ['\u0627\u0644\u0631\u0651\u064e\u062d\u0650\u064a\u0645\u0650 \u0645\u064e\u0644\u0650\u0643\u0650', '\u0646\u064e\u0639\u0652\u0628\u064f\u062f\u064f \u0648\u064e\u0625\u0650\u064a\u0651\u064e\u0627\u0643\u064e', '\u0627\u0644\u0652\u0645\u064f\u0633\u0652\u062a\u064e\u0642\u0650\u064a\u0645\u064e \u0635\u0650\u0631\u064e\u0637\u064e']", 
            "title": "Analysis Tools"
        }, 
        {
            "location": "/analysis_tools/#count_shape", 
            "text": "count_shape(text, system=None)  counts all the letters given a system.  Arguments   text :  (str) or [str]  system :  (system), see  Alphabetical System .   Return  A  numpy    \nmatrix, where   is the number of ayat and   is the number of letters in  system .  Example  user_defined_system = [[beh, teh, theh], [jeem, hah, khah]]\nAlNsr = get_sura(110)\nq.count_shape(AlNsr, user_defined_system)\n\nOut:\n[[1, 0, 0, 0, 1, 0, 4, 1, 0, 2, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 3, 0, 1, 1, 1, 0, 0],\n [0, 0, 2, 0, 0, 0, 5, 1, 0, 2, 2, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 4, 0, 3, 1, 3, 1, 3],\n [0, 0, 0, 0, 1, 0, 4, 6, 0, 2, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0, 0, 1, 2, 0, 2, 0, 1, 2, 2, 2, 0, 0]]", 
            "title": "count_shape"
        }, 
        {
            "location": "/analysis_tools/#count_token", 
            "text": "count_token(text)  Counts the number of words of a Sura.  Arguments   text :  it can be sura [str] or (str)   Example  AlKwther = get_sura(108)\nq.count_token(AlKwther)\n\nOut: 10", 
            "title": "count_token"
        }, 
        {
            "location": "/analysis_tools/#frequency_of_character", 
            "text": "frequency_of_character(characters, verse=None, chapterNum=0, verseNum=0, with_tashkeel=False):  computes the letters freqency in an Aya.  Arguments   verse : (str) if you passed a verse, counts will be applied to this verse only.  chapterNum : (int) if you passed it, counts will be applied to this Sura.  verseNum  (int):  if you passed it only, counts will be applied to the same verse number in all quran.  if passed you passed it with  chapterNum , it will applied to verseNum in sura number   chapterNum .    with_tashkeel  (bool):  if  True , counts will be applied to Quran with diacritics.  if  False  counts will be applied to Quran without diacritics.    If you don't pass any optional arguments, counts will be applied to the hole Quran.   Example  q.frequency_of_character([alef, beh], 114, 1)\nOut: {'\u0627': 2, '\u0628': 2}", 
            "title": "frequency_of_character"
        }, 
        {
            "location": "/analysis_tools/#generate_frequancy_dictionary", 
            "text": "generate_frequency_dictionary(suraNumber=None)  counts the frequency of words in a Sura  Arguments   suraNumber :  (int)  If you don't pass the suraNumber, it will compute the words frequency in the hole Quran.   Example  q.generate_frequency_dictionary(108)\nOut: \n{'\u0623\u0639\u0637\u064a\u0646\u0643': 1,\n '\u0625\u0646': 1,\n '\u0625\u0646\u0627': 1,\n '\u0627\u0644\u0623\u0628\u062a\u0631': 1,\n '\u0627\u0644\u0643\u0648\u062b\u0631': 1,\n '\u0634\u0627\u0646\u0626\u0643': 1,\n '\u0641\u0635\u0644': 1,\n '\u0644\u0631\u0628\u0643': 1,\n '\u0647\u0648': 1,\n '\u0648\u0627\u0646\u062d\u0631': 1}", 
            "title": "generate_frequancy_dictionary"
        }, 
        {
            "location": "/analysis_tools/#sort_dictionary_by_similarity", 
            "text": "sort_dictionary_by_similarity(frequency_dictionary, threshold=0.8)  @Umar, PUT THE REFERENCE !!  Arguments   frequency_dictionary :  which is generated by  generate_frequency_dictionary  threshold : (int) @Umar Define the similarity according to the library you\n  have used!!   Example  q.sort_dictionary_by_similarity(dictionaryFrequency)\n\nOut: {'\u0627\u0644\u0646\u0627\u0633': 4, '\u0627\u0644\u062e\u0646\u0627\u0633': 1, '\u0648\u0627\u0644\u0646\u0627\u0633': 1, '\u0645\u0646': 2, '\u0642\u0644': 1, '\u0623\u0639\u0648\u0630': 1, '\u0628\u0631\u0628': 1, '\u0645\u0644\u0643': 1, '\u0625\u0644\u0647': 1, '\u0634\u0631': 1, '\u0627\u0644\u0648\u0633\u0648\u0627\u0633': 1, '\u0627\u0644\u0630\u0649': 1, '\u064a\u0648\u0633\u0648\u0633': 1, '\u0641\u0649': 1, '\u0635\u062f\u0648\u0631': 1, '\u0627\u0644\u062c\u0646\u0629': 1}", 
            "title": "sort_dictionary_by_similarity"
        }, 
        {
            "location": "/analysis_tools/#generate_latex_table", 
            "text": "generate_latex_table(dictionary, filename, location= . )  generates LaTeX code of frequency table. Returns  True  in case of success, False  otherwise.  Arguments   dictionary :  which is generated by  generate_frequency_dictionary  filename : the output latex file name.  location : (str) path.   Example  q.generate_latex_table(dictionaryFrequency,'any_file_name')\nOut: True", 
            "title": "generate_latex_table"
        }, 
        {
            "location": "/analysis_tools/#search_string_with_tashkeel", 
            "text": "search_string_with_tashkeel(sentence, tashkeel_pattern)  search text with diacritics pattern.  Arguments   sentence : (str)  tashkeel_pattern : ([str]) a list of diacritics pattern.   Return  A list of matching tokens in the text [(start_index, end_index)].  NOTE : Start index is inclusive and End index is exclusive.  Example  sentence = '\u0635\u0650\u0641\u0652 \u0630\u064e\u0627\u0652 \u062b\u064e\u0646\u064e\u0627\u0652 \u0643\u064e\u0645\u0652 \u062c\u064e\u0627\u0652\u062f\u064e \u0634\u064e\u062e\u0652\u0635\u064c'\ntashkeel_pattern = fatha + sukun\nq.search_string_with_tashkeel(sentence,tashkeel_pattern)\nOut: [(3, 5), (7, 9), (10, 12), (13, 15), (17, 19)]", 
            "title": "search_string_with_tashkeel"
        }, 
        {
            "location": "/analysis_tools/#search_sequence", 
            "text": "search_sequence(sequancesList, verse=None, chapterNum=0, verseNum=0, mode=3)  @Umar; Revise this.\n- take list of sequances and return matched sequance, it search in verse ot chapter or All Quran,\n    - it return for every match :\n         - matched sequance \n         - chapter number of occurrence\n         - token number if word and 0 if sentence  - Note :\n     - if found verse != None it will use it en search .    \n     - if no verse and found chapterNum and verseNum it will use this verse and use it to search.\n     - if no verse and no verseNum and found chapterNum it will search in chapter.\n     - if no verse and no chapterNum and no verseNum it will search in All Quran.\n\n- it has many modes:\n    1. search with decorated sequance (with tashkeel), and return matched sequance with decorates (with tashkil).\n    2. search without decorated sequance (without tashkeel), and return matched sequance without decorates (without tashkil).\n    3. search without decorated sequance (without tashkeel), and return matched sequance with decorates (with tashkil).\n\n\n- optional opptions: \n    - **verse** (str): if passed, it will applied to this string only \n    - **chapterNum** (int) : if passed only, it will applied to this chapter only.\n    - **verseNum** (int) :\n        - if passed only, it will applied to **verseNum** for **all Chapters**.\n        - if passed with **chapterNum**, it will applied to verseNum for **chapterNum**.\n    - **with_tashkeel** (bool):\n        - if **True** applied to Quran **with** Tashkieel.\n        - if **False** applied to Quran **without** Tashkieel.\n        - mode (int): this mode that you need to use and default mode 3\n\n- Note : if don't pass any  **optional opptions** it will applied to all **Quran**.\n- Returns: dict() : key is sequances and value is a list of matched_sequance and their positions  q.search_sequence(['\u0642\u0644 \u0623\u0639\u0648\u0630 \u0628\u0631\u0628'])\nOut: {'\u0642\u0644 \u0623\u0639\u0648\u0630 \u0628\u0631\u0628': [('\u0642\u064f\u0644\u0652 \u0623\u064e\u0639\u064f\u0648\u0630\u064f \u0628\u0650\u0631\u064e\u0628\u0651\u0650', 0, 1, 113), ('\u0642\u064f\u0644\u0652 \u0623\u064e\u0639\u064f\u0648\u0630\u064f \u0628\u0650\u0631\u064e\u0628\u0651\u0650', 0, 1, 114)]}", 
            "title": "search_sequence"
        }, 
        {
            "location": "/analysis_tools/#search_with_pattern", 
            "text": "search_with_pattern(pattern,sentence=None,verseNum=None,chapterNum=None,threshold=1)    this function use to search in 0's,1's pattern and return matched words from sentence pattern dependent on the    threshold, it takes a  patter  that you need to looking for , and  sentence (optional)  (sentence where will   search),  chapterNum (opetional)  and  verseNum (opetional)  and return list of matched words and sentences.     Cases:    if pass sentece only or with another args \n   it will search in sentece only.  if not passed sentence and passed verseNum and chapterNum,\n   it will search in this verseNum that exist in chapterNum only.  if not passed sentence,verseNum and passed chapterNum only,\n   it will search in this specific chapter only     Note : it's takes time dependent on your threshold and size of chapter, so it's not support to search on All-Quran becouse it take very long time more than 11 min.      q.search_with_pattern(pattern= 01111 ,chapterNum=1,threshold=0.9)\nOut: ['\u0627\u0644\u0631\u0651\u064e\u062d\u0650\u064a\u0645\u0650 \u0645\u064e\u0644\u0650\u0643\u0650', '\u0646\u064e\u0639\u0652\u0628\u064f\u062f\u064f \u0648\u064e\u0625\u0650\u064a\u0651\u064e\u0627\u0643\u064e', '\u0627\u0644\u0652\u0645\u064f\u0633\u0652\u062a\u064e\u0642\u0650\u064a\u0645\u064e \u0635\u0650\u0631\u064e\u0637\u064e']", 
            "title": "search_with_pattern"
        }, 
        {
            "location": "/CONTRIBUTING/", 
            "text": "Contributing to PyQuran\n\n\nWe use GitHub issues for reporting bugs and for feature requests.\n\n\nIf you want to give us a hand, you may pick one of the opened issues and solve a bug, implement a feature request\nor to suggest a new missing feature.\n\n\nReporting issues\n\n\nWhen reporting a bug, use GitHub issue with the \nBug label\n, please include  as \nmuch details as possible about:\n- your operating system.\n- your python version.\n- a self-contained code to reproduce and demonstrate the Bug.\n\n\nIssue will be closed if the Bug cannot be reproduced.\n\n\nFeature Request\n\n\nWhenever you think \nPyQuran\n is missing a feature, create a GitHub issue with \nFeature Request label\n,\ndefine what you want precisely and include sufficient examples to cover all the new feature aspects.\n\n\nIf you would like to implement it by yourself, please read the \nContributing Code\n section.\n\n\nContributing Code\n\n\n_not_completed\n\n\ncode conventions\n\n\nYour code have to meet \nthese standartds\n,\nand follow \nthis style\n.\n\n\ncontributing flow\n\n\nAt first, fork the project \non GitHub\n,\nthen, create a \nfeature branch\n and start writing your changes. \nWe \nDO NOT\n accept changes to the \nmaster branch\n.\n\n\nOnce you are done, push the changes to \nyour feature branch\n, after that create a \npull request\n\nwith an expressive title and description.\n\n\ncommit messages\n\n\nIt is so important to commit properly\n, we expect you to commit every one logical change.\nA commit message should describe what have been changed, why, and reference issues fixed (if\nany). \n\n\nCommit Message Properties\n:\n1. The Fist line is the commit title, should be less then or equal 50 characters, it must be expressive.\n2. Keep the second line blank.\n3. Wrap all other lines in the message body at 80 columns.\n4. Include \nFixes #N\n, where \nN\n is the issue number the commit\n    fixes, if any.\n\n\nCommits should look like the following:\n\n\nexplain commit in one line\n\nBody of commit message is a few lines of text, explaining things\nin more detail, possibly giving some background about the issue\nbeing fixed, etc.\n\nThe body of the commit message **can be several paragraphs**, and\nplease do proper word-wrap and keep columns shorter than about\n80 characters.\n\nFixes #101\n\n\n\n\nTests\n\n\n_not_completed", 
            "title": "Getting Started"
        }, 
        {
            "location": "/CONTRIBUTING/#contributing-to-pyquran", 
            "text": "We use GitHub issues for reporting bugs and for feature requests.  If you want to give us a hand, you may pick one of the opened issues and solve a bug, implement a feature request\nor to suggest a new missing feature.", 
            "title": "Contributing to PyQuran"
        }, 
        {
            "location": "/CONTRIBUTING/#reporting-issues", 
            "text": "When reporting a bug, use GitHub issue with the  Bug label , please include  as \nmuch details as possible about:\n- your operating system.\n- your python version.\n- a self-contained code to reproduce and demonstrate the Bug.  Issue will be closed if the Bug cannot be reproduced.", 
            "title": "Reporting issues"
        }, 
        {
            "location": "/CONTRIBUTING/#feature-request", 
            "text": "Whenever you think  PyQuran  is missing a feature, create a GitHub issue with  Feature Request label ,\ndefine what you want precisely and include sufficient examples to cover all the new feature aspects.  If you would like to implement it by yourself, please read the  Contributing Code  section.", 
            "title": "Feature Request"
        }, 
        {
            "location": "/CONTRIBUTING/#contributing-code", 
            "text": "_not_completed", 
            "title": "Contributing Code"
        }, 
        {
            "location": "/CONTRIBUTING/#code-conventions", 
            "text": "Your code have to meet  these standartds ,\nand follow  this style .", 
            "title": "code conventions"
        }, 
        {
            "location": "/CONTRIBUTING/#contributing-flow", 
            "text": "At first, fork the project  on GitHub ,\nthen, create a  feature branch  and start writing your changes. \nWe  DO NOT  accept changes to the  master branch .  Once you are done, push the changes to  your feature branch , after that create a  pull request \nwith an expressive title and description.", 
            "title": "contributing flow"
        }, 
        {
            "location": "/CONTRIBUTING/#commit-messages", 
            "text": "It is so important to commit properly , we expect you to commit every one logical change.\nA commit message should describe what have been changed, why, and reference issues fixed (if\nany).   Commit Message Properties :\n1. The Fist line is the commit title, should be less then or equal 50 characters, it must be expressive.\n2. Keep the second line blank.\n3. Wrap all other lines in the message body at 80 columns.\n4. Include  Fixes #N , where  N  is the issue number the commit\n    fixes, if any.  Commits should look like the following:  explain commit in one line\n\nBody of commit message is a few lines of text, explaining things\nin more detail, possibly giving some background about the issue\nbeing fixed, etc.\n\nThe body of the commit message **can be several paragraphs**, and\nplease do proper word-wrap and keep columns shorter than about\n80 characters.\n\nFixes #101", 
            "title": "commit messages"
        }, 
        {
            "location": "/CONTRIBUTING/#tests", 
            "text": "_not_completed", 
            "title": "Tests"
        }
    ]
}