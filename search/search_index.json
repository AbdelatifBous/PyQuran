{
    "docs": [
        {
            "location": "/", 
            "text": "PyQuran: The Python package for Quranic Analysis\n\n\nPyQuran is a package which provides tools for \nQuranic Analysis\n.\n\n\nIt is still a small package which needs a lot of your effort. We believe that it\nis a seed of a fundamental general package for\ncomputations on \nQuran\n with Python, even at the most basic level which simply retrieving Quran text.\n\n\nBefore Islam\n, Arabic letters  were without  dots\u2014\n\nrasm\n, which resulted in ambiguty, two or three\nletters had the same rasm/form/shape/look. \n\n\nMuslims have decided to remove this ambiguity by adding\ndots above or below each letter of the ones which share the same rasm. Now each letter has a unique form. By the way,\noriginally, \nQuran\n was written without dots on the letters.\n\n\nTo enable you to use both modern system or other, we introduce \nalphabetical systems\n,\nIt is a dynamic construction of letters\u2014\n\nAlphabetical Systems\n.\n\n\nCurrent Features\n\n\n\n\nfetch chapters and verses.\n\n\nsearch Quran by text tokens and by diacritics patterns.\n\n\nbuckwalter transliteration, back and forth\n\n\nMultiple \nalphabetical systems\n, \nfor more details see the \nPyQuran Wiki\n\n\n\n\nInstall\n\n\n\n\nFrom \nPyPI\n: \n$ pip3 install pyquran\n\n\nFrom Source: \n$ python3 setup.py install\n\n\n\n\nDependencies\n\n\n\n\nnumpy\n\n\npyarabic\n\n\n\n\nQuran Corpus\n\n\nWe use \ntanzil\n Quran Corpus (\nUthmani Text\n), it is in \nUTF-8\n encoding. You\ncan find all unique characters of Uthmanic Corpus\n\nhere\n.\n\n\nThere are \nspecial recitation symbols\n \u0645\u0635\u0637\u0644\u062d\u0627\u062a \u0627\u0644\u0636\u0628\u0637 in the \nUthmani Text\n, they are a guide for the reciter\nto know the right positions to pause and the rules of tajweed.\nWe provide an interface to filter those symbols, \nonly the fly while fetching from the corpus\n,\nwe \nDO NOT\n change the corpus, NEVER.\n\n\nFor the full details about filtering \nspecial recitation symbols\n \u0645\u0635\u0637\u0644\u062d\u0627\u062a \u0627\u0644\u0636\u0628\u0637.\n\n\nContributing\n\n\nTo contribute and maintain \nPyQuran\n, Please read  \nCONTRIBUTING.md\n.\n\n\nSee also \nHow to contribute to PyQuran\n.\n\n\nCiting\n\n\nnot_completed_ (need to disscuss it with the prof.)\nCite \nPyQuran\n as the following \nBibTeX\n entry.\n\n\n@MISC {PyQuran2018,\nauthor             = \nWaleed A. Yousef\n,\ntitle              = \nPyQuran\n,\nhowpublished       = \nhttps://github.com/TahaMagdy/PyQuran\n,\nmonth              = \nfeb\n,\nyear               = \n2018\n\n}\n\n\n\n\nCommunication\n\n\n\u0640not_completed_\n\n\nLicence\n\n\nnot_completed_ (need to discuss it with the prof.)", 
            "title": "Home"
        }, 
        {
            "location": "/#pyquran-the-python-package-for-quranic-analysis", 
            "text": "PyQuran is a package which provides tools for  Quranic Analysis .  It is still a small package which needs a lot of your effort. We believe that it\nis a seed of a fundamental general package for\ncomputations on  Quran  with Python, even at the most basic level which simply retrieving Quran text.  Before Islam , Arabic letters  were without  dots\u2014 rasm , which resulted in ambiguty, two or three\nletters had the same rasm/form/shape/look.   Muslims have decided to remove this ambiguity by adding\ndots above or below each letter of the ones which share the same rasm. Now each letter has a unique form. By the way,\noriginally,  Quran  was written without dots on the letters.  To enable you to use both modern system or other, we introduce  alphabetical systems ,\nIt is a dynamic construction of letters\u2014 Alphabetical Systems .", 
            "title": "PyQuran: The Python package for Quranic Analysis"
        }, 
        {
            "location": "/#current-features", 
            "text": "fetch chapters and verses.  search Quran by text tokens and by diacritics patterns.  buckwalter transliteration, back and forth  Multiple  alphabetical systems ,  for more details see the  PyQuran Wiki", 
            "title": "Current Features"
        }, 
        {
            "location": "/#install", 
            "text": "From  PyPI :  $ pip3 install pyquran  From Source:  $ python3 setup.py install", 
            "title": "Install"
        }, 
        {
            "location": "/#dependencies", 
            "text": "numpy  pyarabic", 
            "title": "Dependencies"
        }, 
        {
            "location": "/#quran-corpus", 
            "text": "We use  tanzil  Quran Corpus ( Uthmani Text ), it is in  UTF-8  encoding. You\ncan find all unique characters of Uthmanic Corpus here .  There are  special recitation symbols  \u0645\u0635\u0637\u0644\u062d\u0627\u062a \u0627\u0644\u0636\u0628\u0637 in the  Uthmani Text , they are a guide for the reciter\nto know the right positions to pause and the rules of tajweed.\nWe provide an interface to filter those symbols,  only the fly while fetching from the corpus ,\nwe  DO NOT  change the corpus, NEVER.  For the full details about filtering  special recitation symbols  \u0645\u0635\u0637\u0644\u062d\u0627\u062a \u0627\u0644\u0636\u0628\u0637.", 
            "title": "Quran Corpus"
        }, 
        {
            "location": "/#contributing", 
            "text": "To contribute and maintain  PyQuran , Please read   CONTRIBUTING.md .  See also  How to contribute to PyQuran .", 
            "title": "Contributing"
        }, 
        {
            "location": "/#citing", 
            "text": "not_completed_ (need to disscuss it with the prof.)\nCite  PyQuran  as the following  BibTeX  entry.  @MISC {PyQuran2018,\nauthor             =  Waleed A. Yousef ,\ntitle              =  PyQuran ,\nhowpublished       =  https://github.com/TahaMagdy/PyQuran ,\nmonth              =  feb ,\nyear               =  2018 \n}", 
            "title": "Citing"
        }, 
        {
            "location": "/#communication", 
            "text": "\u0640not_completed_", 
            "title": "Communication"
        }, 
        {
            "location": "/#licence", 
            "text": "not_completed_ (need to discuss it with the prof.)", 
            "title": "Licence"
        }, 
        {
            "location": "/quran_tools/", 
            "text": "Retrieving Quran\n\n\nPyQuran is a set of functions and variables.\n\n\nimport pyquran as q\n\n\n\n\nget_sura\n\n\nget_sura(sura_number, with_tashkeel=False)\n\n\n\n\nReturns a list of verses, where verses are nothing but strings.\n\n\nArguments\n\n\n\n\nsura_number\n:   (int)the ordered number of sura in The Mushaf, starting from 1.\n\n\nwith_tashkeel\n: (bool) to return verses with diacritics to not.\n\n\n\n\nExample\n\n\nq.get_sura(108, True)\nOut: ['\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e', '\u0641\u064e\u0635\u064e\u0644\u0651\u0650 \u0644\u0650\u0631\u064e\u0628\u0651\u0650\u0643\u064e \u0648\u064e\u0627\u0646\u0652\u062d\u064e\u0631\u0652', '\u0625\u0650\u0646\u0651\u064e \u0634\u064e\u0627\u0646\u0650\u0626\u064e\u0643\u064e \u0647\u064f\u0648\u064e \u0627\u0644\u0652\u0623\u064e\u0628\u0652\u062a\u064e\u0631\u064f']\n\n\n\n\n\n\nfetch_aya\n\n\nq.fetch_aya(sura_number, aya_number)\n\n\n\n\nReturns a verse.\n\n\nArguments\n\n\n\n\nsura_number\n: (int) the ordered number of sura in The Mus'haf.\n\n\naya_number\n:  (int) the ordered number of aya in The Mus'haf.\n\n\n\n\nExample\n\n\nq.fetch_aya(1, 2)\nOut: '\u0627\u0644\u062d\u0645\u062f \u0644\u0644\u0647 \u0631\u0628 \u0627\u0644\u0639\u0644\u0645\u064a\u0646'\n\n\n\n\n\n\nget_sura_name\n\n\nq.get_sura_name(suraNumber=None)\n\n\n\n\nReturns the Arabic name of a Sura.\n\n\nArguments\n\n\n\n\nsuraNumber\n:   (int) the ordered number of sura in The Mushaf, starting from 1.\n\n\n\n\nExample\n\n\nq.get_sura_name(2)\nOut: '\u0627\u0644\u0628\u0642\u0631\u0629'\n\n\n\n\n\n\nget_sura_number\n\n\nq.get_sura_number(suraName)\n\n\n\n\nReturns the Arabic name of a Sura.\n\n\nArguments\n\n\n\n\nsuraName\n:  (str) The Arabic Sura name.\n\n\n\n\nExample\n\n\npq.get_sura_number('\u0627\u0644\u0645\u0644\u0643')\n\n 67", 
            "title": "Basic Tools for Quran"
        }, 
        {
            "location": "/quran_tools/#retrieving-quran", 
            "text": "PyQuran is a set of functions and variables.  import pyquran as q", 
            "title": "Retrieving Quran"
        }, 
        {
            "location": "/quran_tools/#get_sura", 
            "text": "get_sura(sura_number, with_tashkeel=False)  Returns a list of verses, where verses are nothing but strings.  Arguments   sura_number :   (int)the ordered number of sura in The Mushaf, starting from 1.  with_tashkeel : (bool) to return verses with diacritics to not.   Example  q.get_sura(108, True)\nOut: ['\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e', '\u0641\u064e\u0635\u064e\u0644\u0651\u0650 \u0644\u0650\u0631\u064e\u0628\u0651\u0650\u0643\u064e \u0648\u064e\u0627\u0646\u0652\u062d\u064e\u0631\u0652', '\u0625\u0650\u0646\u0651\u064e \u0634\u064e\u0627\u0646\u0650\u0626\u064e\u0643\u064e \u0647\u064f\u0648\u064e \u0627\u0644\u0652\u0623\u064e\u0628\u0652\u062a\u064e\u0631\u064f']", 
            "title": "get_sura"
        }, 
        {
            "location": "/quran_tools/#fetch_aya", 
            "text": "q.fetch_aya(sura_number, aya_number)  Returns a verse.  Arguments   sura_number : (int) the ordered number of sura in The Mus'haf.  aya_number :  (int) the ordered number of aya in The Mus'haf.   Example  q.fetch_aya(1, 2)\nOut: '\u0627\u0644\u062d\u0645\u062f \u0644\u0644\u0647 \u0631\u0628 \u0627\u0644\u0639\u0644\u0645\u064a\u0646'", 
            "title": "fetch_aya"
        }, 
        {
            "location": "/quran_tools/#get_sura_name", 
            "text": "q.get_sura_name(suraNumber=None)  Returns the Arabic name of a Sura.  Arguments   suraNumber :   (int) the ordered number of sura in The Mushaf, starting from 1.   Example  q.get_sura_name(2)\nOut: '\u0627\u0644\u0628\u0642\u0631\u0629'", 
            "title": "get_sura_name"
        }, 
        {
            "location": "/quran_tools/#get_sura_number", 
            "text": "q.get_sura_number(suraName)  Returns the Arabic name of a Sura.  Arguments   suraName :  (str) The Arabic Sura name.   Example  pq.get_sura_number('\u0627\u0644\u0645\u0644\u0643')  67", 
            "title": "get_sura_number"
        }, 
        {
            "location": "/arabic_tools/", 
            "text": "Alphabets\n\n\nWe use \nPyArabic\n constants which\nrepresents letters, instead of writting Arabic in the code.\n\n\nhamza            = u'\\u0621'\nalef_mad         = u'\\u0622'\nalef_hamza_above = u'\\u0623'\nwaw_hamza        = u'\\u0624'\nalef_hamza_below = u'\\u0625'\nyeh_hamza        = u'\\u0626'\nalef             = u'\\u0627'\nbeh              = u'\\u0628'\nteh_marbuta      = u'\\u0629'\nteh              = u'\\u062a'\ntheh             = u'\\u062b'\njeem             = u'\\u062c'\nhah              = u'\\u062d'\nkhah             = u'\\u062e'\ndal              = u'\\u062f'\nthal             = u'\\u0630'\nreh              = u'\\u0631'\nzain             = u'\\u0632'\nseen             = u'\\u0633'\nsheen            = u'\\u0634'\nsad              = u'\\u0635'\ndad              = u'\\u0636'\ntah              = u'\\u0637'\nzah              = u'\\u0638'\nain              = u'\\u0639'\nghain            = u'\\u063a'\nfeh              = u'\\u0641'\nqaf              = u'\\u0642'\nkaf              = u'\\u0643'\nlam              = u'\\u0644'\nmeem             = u'\\u0645'\nnoon             = u'\\u0646'\nheh              = u'\\u0647'\nwaw              = u'\\u0648'\nalef_maksura     = u'\\u0649'\nyeh              = u'\\u064a'\nmadda_above      = u'\\u0653'\nhamza_above      = u'\\u0654'\nhamza_below      = u'\\u0655'\nalef_wasl        = u'\\u0671'\n\n\n\n\nAlphabetical Systems\n\n\nWe define \nalphabetical system\n as a dynamic construction of letters in which\nyou can treat a group of letters one letter. The default alphabet is a special\ncase of the Alphabetical System where each letter is treated as one letter.\n\n\nPredefined systems\n are stored in \nsystems\n object.\n\n\n\n\ndefault.\n\n\nwithout dots system.\n\n\nhamazat.\n\n\n\n\nExample:\n\n\nq.systems.withoutDots\nOut: \n[['\u0628', '\u062a', '\u062b', '\u0646'],\n ['\u062d', '\u062e', '\u062c'],\n ['\u062f', '\u0630'],\n ['\u0631', '\u0632'],\n ['\u0633', '\u0634'],\n ['\u0635', '\u0636'],\n ['\u0637', '\u0638'],\n ['\u0639', '\u063a'],\n ['\u0641', '\u0642']]\n\n\n\n\nConstruct a user-defined system\n:\n\n\nsystem = [[alef_hamza_above, alef],[beh, teh]]\n\n\n\n\nThe previous line of code means \"Treat \nalef_hamza_above\n and \nalef\n\nas the same one latter, also treat \nbeh\n and \nteh\n as one letter as well\"\n\n\nAnd then, a system can be applied to some text analysis functions like counting,\nfiltering, etc.\n\n\ncheck_system\n\n\ncheck_system(system, index=None)\n\n\n\n\nReturns the alphabet including treated-as-one letters. If you pass the index as\nthe second optional arguement, it returns the letter of the that index only, not the\nhole alphabet.\n\n\nArguments\n\n\n\n\nsystem\n:  a list of letters, where each letter to be treated as one letter\n  are in one sublist. see \nAlphabetical Systems\n\n\nindex\n: (int) is a index of a letter in the new system.\n\n\n\n\nExample\n\n\nThis prints each letter as one element in a new alphabet list, as you can see the\ntwo letters \nalef\n and \nbeh\n are considered one letter.\n\n\nq.check_system([['alef', 'beh']])\nOut: \n[['\u0621'],\n ['\u0622'],\n ['\u0623', '\u0628'],\n ['\u0624'],\n ['\u0625'],\n ['\u0626'],\n ['\u0627'],\n ['\u0629'],\n ['\u062a'],\n ['\u062b'],\n ['\u062c'],\n ['\u062d'],\n ['\u062e'],\n ['\u062f'],\n ['\u0630'],\n ['\u0631'],\n ['\u0632'],\n ['\u0633'],\n ['\u0634'],\n ['\u0635'],\n ['\u0636'],\n ['\u0637'],\n ['\u0638'],\n ['\u0639'],\n ['\u063a'],\n ['\u0641'],\n ['\u0642'],\n ['\u0643'],\n ['\u0644'],\n ['\u0645'],\n ['\u0646'],\n ['\u0647'],\n ['\u0648'],\n ['\u0649'],\n ['\u064a']]\n\n\n\n\n\n\n\nbuckwalter_transliteration\n\n\nBack and forth bauckwalter-arabic transliteration.\n\n\nNOTE\n: Revise \nBuckwalter\n\n\nq.buckwalter_transliteration('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\nOut: \nin~aA \naEoTayonaka Alokawovara", 
            "title": "Arabic Tools"
        }, 
        {
            "location": "/arabic_tools/#alphabets", 
            "text": "We use  PyArabic  constants which\nrepresents letters, instead of writting Arabic in the code.  hamza            = u'\\u0621'\nalef_mad         = u'\\u0622'\nalef_hamza_above = u'\\u0623'\nwaw_hamza        = u'\\u0624'\nalef_hamza_below = u'\\u0625'\nyeh_hamza        = u'\\u0626'\nalef             = u'\\u0627'\nbeh              = u'\\u0628'\nteh_marbuta      = u'\\u0629'\nteh              = u'\\u062a'\ntheh             = u'\\u062b'\njeem             = u'\\u062c'\nhah              = u'\\u062d'\nkhah             = u'\\u062e'\ndal              = u'\\u062f'\nthal             = u'\\u0630'\nreh              = u'\\u0631'\nzain             = u'\\u0632'\nseen             = u'\\u0633'\nsheen            = u'\\u0634'\nsad              = u'\\u0635'\ndad              = u'\\u0636'\ntah              = u'\\u0637'\nzah              = u'\\u0638'\nain              = u'\\u0639'\nghain            = u'\\u063a'\nfeh              = u'\\u0641'\nqaf              = u'\\u0642'\nkaf              = u'\\u0643'\nlam              = u'\\u0644'\nmeem             = u'\\u0645'\nnoon             = u'\\u0646'\nheh              = u'\\u0647'\nwaw              = u'\\u0648'\nalef_maksura     = u'\\u0649'\nyeh              = u'\\u064a'\nmadda_above      = u'\\u0653'\nhamza_above      = u'\\u0654'\nhamza_below      = u'\\u0655'\nalef_wasl        = u'\\u0671'", 
            "title": "Alphabets"
        }, 
        {
            "location": "/arabic_tools/#alphabetical-systems", 
            "text": "We define  alphabetical system  as a dynamic construction of letters in which\nyou can treat a group of letters one letter. The default alphabet is a special\ncase of the Alphabetical System where each letter is treated as one letter.  Predefined systems  are stored in  systems  object.   default.  without dots system.  hamazat.   Example:  q.systems.withoutDots\nOut: \n[['\u0628', '\u062a', '\u062b', '\u0646'],\n ['\u062d', '\u062e', '\u062c'],\n ['\u062f', '\u0630'],\n ['\u0631', '\u0632'],\n ['\u0633', '\u0634'],\n ['\u0635', '\u0636'],\n ['\u0637', '\u0638'],\n ['\u0639', '\u063a'],\n ['\u0641', '\u0642']]  Construct a user-defined system :  system = [[alef_hamza_above, alef],[beh, teh]]  The previous line of code means \"Treat  alef_hamza_above  and  alef \nas the same one latter, also treat  beh  and  teh  as one letter as well\"  And then, a system can be applied to some text analysis functions like counting,\nfiltering, etc.", 
            "title": "Alphabetical Systems"
        }, 
        {
            "location": "/arabic_tools/#check_system", 
            "text": "check_system(system, index=None)  Returns the alphabet including treated-as-one letters. If you pass the index as\nthe second optional arguement, it returns the letter of the that index only, not the\nhole alphabet.  Arguments   system :  a list of letters, where each letter to be treated as one letter\n  are in one sublist. see  Alphabetical Systems  index : (int) is a index of a letter in the new system.   Example  This prints each letter as one element in a new alphabet list, as you can see the\ntwo letters  alef  and  beh  are considered one letter.  q.check_system([['alef', 'beh']])\nOut: \n[['\u0621'],\n ['\u0622'],\n ['\u0623', '\u0628'],\n ['\u0624'],\n ['\u0625'],\n ['\u0626'],\n ['\u0627'],\n ['\u0629'],\n ['\u062a'],\n ['\u062b'],\n ['\u062c'],\n ['\u062d'],\n ['\u062e'],\n ['\u062f'],\n ['\u0630'],\n ['\u0631'],\n ['\u0632'],\n ['\u0633'],\n ['\u0634'],\n ['\u0635'],\n ['\u0636'],\n ['\u0637'],\n ['\u0638'],\n ['\u0639'],\n ['\u063a'],\n ['\u0641'],\n ['\u0642'],\n ['\u0643'],\n ['\u0644'],\n ['\u0645'],\n ['\u0646'],\n ['\u0647'],\n ['\u0648'],\n ['\u0649'],\n ['\u064a']]", 
            "title": "check_system"
        }, 
        {
            "location": "/arabic_tools/#buckwalter_transliteration", 
            "text": "Back and forth bauckwalter-arabic transliteration.  NOTE : Revise  Buckwalter  q.buckwalter_transliteration('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\nOut:  in~aA  aEoTayonaka Alokawovara", 
            "title": "buckwalter_transliteration"
        }, 
        {
            "location": "/methods guide/", 
            "text": "X\n\n\n\n\nX\n\n\nArguments\n\n\n\n\nX\n:  X\n\n\n\n\nExample\n\n\nX\n\n\n\n\n\n\n\n\nThbeed\n\n\n\n\nFeatures\n\n\nImporatan information\n\n\nUsage\n\n\nFunctions\n\n\nAccess functions\n\n    [x] DONE\n\n\nManipulate functions\n\n\nseparate_token_with_diacritics\n\n\nget_tashkeel_binary\n\n\nunpack_alef_mad\n\n\nshape\n\n\ncheck_all_alphabet\n\n\nbuckwalter_transliteration\n\n\nextract_tashkeel\n\n\n\n\n\n\nAnalysis functions\n\n\ncount_shape\n\n\ncount_token\n\n\nfrequency_of_character\n \n\n\ngenerate_frequancy_dictionary\n\n\nsort_dictionary_by_similarity\n\n\ncheck_sura_with_frequency\n\n\ngenerate_latex_table\n\n\n\n\n\n\nSearch functions\n\n\nsearch_sequence\n\n\nsearch_string_with_tashkeel\n\n\nsearch_with_pattern\n\n\n\n\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nAccess Holy-Quran :\n\n\nget \nChapter\n with/without diacritics.\n\n\nget \nVerse\n with/without diacritics.\n\n\nget \nToken\n (word).\n\n\nget \nChapter name\n , \nChapter number\n.\n\n\nget \nVerses number\n in verse.\n\n\n\n\n\n\nManipulate with Holy-Quran :\n\n\nSeparate to \nletters\n with/without diacritics.\n\n\nApply your \nSystem\n on Quran.\n\n\nget \nBinary representation\n of Holy-Quran as 0's , 1's.\n\n\nExtract \nTaskill\n from sentence. \n\n\nDealing with linguistic rules like :\n\n\nTransfer Alef-mad \n\"\u0622\"\n to \"\u0623\u064e\u0623\u0652\" \n\n\n\n\n\n\nConvert the \nunicode of arabic\n text to \nbuckwalter encoding\n and vice versa\n\n\nConvert Quran to \nbuckwalter reprsentation\n and vice versa. \n\n\n\n\n\n\nAnalysis Holy-Quran:\n\n\nget \nFrequency Matrix\n of letters dependent on Applied \nalphabet system\n.\n\n\nget \nFrequency dictionary\n of tokens.\n\n\nsort \nFrequency dictionary\n using similarity threshold.\n\n\n\n\n\n\nSearch in Holy-Quran using :\n\n\nText\n and ther is a variety options.\n\n\ndiacritics pattern\n. \n\n\nbinary representation pattern\n using threshold.\n\n\n\n\n\n\n\n\nFunctions\n\n\nManipulate functions:\n\n\nseparate_token_with_diacritics\n\n\nseparate_token_with_diacritics(sentence)\n\n- takes \nsentence\n and separate it to characters with there diacritics.\n\n\n  wordSeparated = pq.separate_token_with_dicrites('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\n  print(wordSeparated)\n\n  \n ['\u0625\u0650', '\u0646\u0651\u064e', '\u0627', ' ', '\u0623\u064e', '\u0639\u0652', '\u0637\u064e', '\u064a\u0652', '\u0646\u064e', '\u0643\u064e', ' ', '\u0627', '\u0644\u0652', '\u0643\u064e', '\u0648\u0652', '\u062b\u064e', '\u0631\u064e']\n\n\n\n\nget_tashkeel_binary\n\n\nget_tashkeel_binary(verse)\n\n- takes the verses content or chapters with diacritics and it returns tuple of the mapping of \nchracters with diacritics\n to \n0's,1's\n and \nharakah\n represented as \n1\n and \nsukun\n represented as \n0\n and return list of diacritics too.\n\n\n  pattern = pq.get_tashkeel_binary('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\n  print(pattern)\n\n  \n ('1010 101011 001011', ['\u0650', '\u0652', '\u064e', '', '', '\u064e', '\u0652', '\u064e', '\u0652', '\u064e', '\u064e', '', '', '\u0652', '\u064e', '\u0652', '\u064e', '\u064e'])\n\n\n\n\n\nunpack_alef_mad\n\n\nunpack_alef_mad(ayahWithAlefMad)\n\n- takes \nayahWithAlefMad\n (sentence that has Alef-Mad) and it returns the sentence after replace \nAlef-mad\n to \nAlef-hamza-above + fatha\n and \nalef-hamza-above + sukun\n.\n\n\n  unpackAlefMad = pq.unpack_alef_mad('\u0622')\n  print(unpackAlefMad)\n\n  \n '\u0623\u0652\u0623\u064e'\n\n\n\n\nbuckwalter_transliteration\n\n\nbuckwalter_transliteration(sentence, reverse)\n\n- takes an \nsentence\n and \nreverse (optional)\n the trnslate option if \nTrue\n convert \nsentence\n from Arabic to BuckWalter and if \nFalse (default)\n convert \nsentence\n from BuckWalter to Arabic.\n\n\nnote\n:the encoding with \ndiacritics\n is  different from \nwithout diacritics**.\n\n\n  buckwalterEncode = pq.buckwalter_transliteration('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\n  print(buckwalterEncode)\n\n  \n \nin~aA \naEoTayonaka Alokawovara\n\n\n\n\nAnalysis functions:\n\n\ncount_shape\n\n\ncount_shape(text, system=None)\n\n- takes \ntext\n (chapter/verse), \nsystem (optional)\n it's the shape of character as example [[bah,gem]] and return a \nn*p matrix\n where \nn\n number of verses and \np\n number of collections in system and if not pass system it will apply the defualt.  \n\n\n  newSystem=[[beh, teh, theh], [jeem, hah, khah]]\n  alphabetAsOneShape =pq.count_shape(get_sura(110), newSystem)\n  print(alphabetAsOneShape)\n\n  \n [[1 2 1 0 0 0 1 0 4 0 0 1 1 0 0 0 1 0 0 0 0 0 1 0 0 3 0 1 1 1 0 0]\n       [1 2 0 0 2 0 0 0 5 0 2 0 1 0 1 0 0 0 0 0 0 0 2 0 0 4 0 3 1 3 1 3]\n       [6 2 0 0 0 0 1 0 4 0 1 0 2 0 2 0 0 0 0 0 0 1 2 0 2 0 1 2 2 2 0 0]]\n\n\n\n\ncount_token\n\n\ncount_token(text)\n \n- takes \ntext\n (chapter/verse) and returns the number of tokens.\n\n\nnote\n: the harf ('\u0648') is not calculated as token alone\n\n\n  numberOfToken=pq.count_token(tools.get_sura(110))\n  print(numberOfToken)\n\n  \n 19\n\n\n\n\nfrequency_of_character\n\n\nfrequency_of_character(characters,verse=None,chapterNum=0,verseNum=0,with_tashkeel=False)\n\n- takes \ncharacters\n that you need to count , return dictionary that havecounts characters occurrence for verses or with chapter or even all quran and the dictionary contains the key char and values is an occurrence of character .\n- optional opptions: \n    - \nverse\n (str): if passed, it will applied to this string only \n    - \nchapterNum\n (int) : if passed only, it will applied to this chapter only.\n    - \nverseNum\n (int) :\n        - if passed only, it will applied to \nverseNum\n for \nall Chapters\n.\n        - if passed with \nchapterNum\n, it will applied to verseNum for \nchapterNum\n.\n    - \nwith_tashkeel\n (bool):\n        - if \nTrue\n applied to Quran \nwith\n Tashkieel.\n        - if \nFalse\n applied to Quran \nwithout\n Tashkieel.\n- Note : if don't pass any  \noptional opptions\n it will applied to all \nQuran\n.\n\n\n  frequencyOfChar =tools.frequency_of_character(['\u0623','\u0628'],'\u0642\u0644 \u0623\u0639\u0648\u0630 \u0628\u0631\u0628 \u0627\u0644\u0646\u0627\u0633',114,1)\n  print(frequencyOfChar)\n\n  \n {\u0623:1,\u0628:2}\n\n\n\n\ngenerate_frequancy_dictionary\n\n\ngenerate_frequency_dictionary(suraNumber=None)\n \n- takes \nsuraNumber (optional)\n the number of chapter and it returns the dictionary of  words contains the \nword\n as key and its \nfrequency\n as value and if not pass \nsuraNumber\n it will applied to \nall-Quran\n.\n\n\n  dictionaryFrequency = pq.generate_frequency_dictionary(114)\n  print(dictionaryFrequency)\n\n  \n {'\u0627\u0644\u0646\u0627\u0633': 4, '\u0645\u0646': 2, '\u0642\u0644': 1, '\u0623\u0639\u0648\u0630': 1, '\u0628\u0631\u0628': 1, '\u0645\u0644\u0643': 1, '\u0625\u0644\u0647': 1, '\u0634\u0631': 1, '\u0627\u0644\u0648\u0633\u0648\u0627\u0633': 1, '\u0627\u0644\u062e\u0646\u0627\u0633': 1, '\u0627\u0644\u0630\u0649': 1, '\u064a\u0648\u0633\u0648\u0633': 1, '\u0641\u0649': 1, '\u0635\u062f\u0648\u0631': 1, '\u0627\u0644\u062c\u0646\u0629': 1, '\u0648\u0627\u0644\u0646\u0627\u0633': 1}\n\n\n\n\nsort_dictionary_by_similarity\n\n\nsort_dictionary_by_similarity(frequency_dictionary,threshold=0.8)\n\n- using to \ncluster words  by using similarity\n and sort every bunch of word  by most common and sort bunches descending in the same time takes the frequency dictionary generated using \ngenerate_frequency_dictionary\n function. This function takes dictionary of frequencies and \nthreshold (optional)\n to specify \nthe degree of similarity\n \n\n\n  sortedDictionary = pq.sort_dictionary_by_similarity(dictionaryFrequency)\n  print(sortedDictionary)\n\n  \n {'\u0627\u0644\u0646\u0627\u0633': 4, '\u0627\u0644\u062e\u0646\u0627\u0633': 1, '\u0648\u0627\u0644\u0646\u0627\u0633': 1, '\u0645\u0646': 2, '\u0642\u0644': 1, '\u0623\u0639\u0648\u0630': 1, '\u0628\u0631\u0628': 1, '\u0645\u0644\u0643': 1, '\u0625\u0644\u0647': 1, '\u0634\u0631': 1, '\u0627\u0644\u0648\u0633\u0648\u0627\u0633': 1, '\u0627\u0644\u0630\u0649': 1, '\u064a\u0648\u0633\u0648\u0633': 1, '\u0641\u0649': 1, '\u0635\u062f\u0648\u0631': 1, '\u0627\u0644\u062c\u0646\u0629': 1}\n\n\n\n\ncheck_sura_with_frequency\n\n\ncheck_sura_with_frequency(sura_num,freq_dec)\n\n- function checks if frequency dictionary of \nspecific chapter\n is compatible with \noriginal chapter\n in quran, it takes \nsura_num\n (chapter number) and \nfreq_dec\n (frequency dictionary) and return \nTrue\n if compatible and \nFalse\n in not.\n\n\n  dictionaryFrequency = pq.generate_frequency_dictionary(111)\n  matched = pq.check_sura_with_frequency(110,dictionaryFrequency)\n  print(matched)\n\n  \n False\n\n\n\n\ngenerate_latex_table\n\n\ngenerate_latex_table(dictionary,filename,location=\".\")\n\n- generates latex code of table of frequency it takes dictionary frequency ,it takes \ndictionary\n (frequency dictionary) , \nfilename\n and \nlocation\n (location to save) , the default location is same directory by symbol '.', then it returns \nTrue\n if the operation of generation completed successfully \nFalse\n if something wrong \n\n\n  latexTable = pq.generate_latex_table(dictionaryFrequency,'any_file_name')\n  print(latexTable)\n\n  \n True\n\n\n\n\nSearch functions\n\n\nsearch_sequence\n\n\nsearch_sequence(sequancesList,verse=None,chapterNum=0,verseNum=0,mode=3)\n\n- take list of sequances and return matched sequance, it search in verse ot chapter or All Quran,\n    - it return for every match :\n         - matched sequance \n         - chapter number of occurrence\n         - token number if word and 0 if sentence\n\n\n- Note :\n     - if found verse != None it will use it en search .    \n     - if no verse and found chapterNum and verseNum it will use this verse and use it to search.\n     - if no verse and no verseNum and found chapterNum it will search in chapter.\n     - if no verse and no chapterNum and no verseNum it will search in All Quran.\n\n- it has many modes:\n    1. search with decorated sequance (with tashkeel), and return matched sequance with decorates (with tashkil).\n    2. search without decorated sequance (without tashkeel), and return matched sequance without decorates (without tashkil).\n    3. search without decorated sequance (without tashkeel), and return matched sequance with decorates (with tashkil).\n\n\n- optional opptions: \n    - **verse** (str): if passed, it will applied to this string only \n    - **chapterNum** (int) : if passed only, it will applied to this chapter only.\n    - **verseNum** (int) :\n        - if passed only, it will applied to **verseNum** for **all Chapters**.\n        - if passed with **chapterNum**, it will applied to verseNum for **chapterNum**.\n    - **with_tashkeel** (bool):\n        - if **True** applied to Quran **with** Tashkieel.\n        - if **False** applied to Quran **without** Tashkieel.\n        - mode (int): this mode that you need to use and default mode 3\n\n- Note : if don't pass any  **optional opptions** it will applied to all **Quran**.\n- Returns: dict() : key is sequances and value is a list of matched_sequance and their positions\n\n\n\n  matchedKeyword = pq.search_sequence(['\u0642\u0644 \u0623\u0639\u0648\u0630 \u0628\u0631\u0628'])\n  print(matchedKeyword)\n\n  \n {'\u0642\u0644 \u0623\u0639\u0648\u0630 \u0628\u0631\u0628': [('\u0642\u064f\u0644\u0652 \u0623\u064e\u0639\u064f\u0648\u0630\u064f \u0628\u0650\u0631\u064e\u0628\u0651\u0650', 0, 1, 113), ('\u0642\u064f\u0644\u0652 \u0623\u064e\u0639\u064f\u0648\u0630\u064f \u0628\u0650\u0631\u064e\u0628\u0651\u0650', 0, 1, 114)]}\n\n\n\n\n\nsearch_string_with_tashkeel\n\n\nsearch_string_with_tashkeel(sentence,tashkeel_pattern)\n\n- takes an \nsentence\n and \ntashkeel_pattern\n (composed of 0's , 1's) and it returns the locations that matched the pattern of diacrictics start index \ninclusive\n and end index \nexculsive\n and return empty list if not found.\n\n\n\n  sentence = '\u0635\u0650\u0641\u0652 \u0630\u064e\u0627\u0652 \u062b\u064e\u0646\u064e\u0627\u0652 \u0643\u064e\u0645\u0652 \u062c\u064e\u0627\u0652\u062f\u064e \u0634\u064e\u062e\u0652\u0635\u064c'\n  tashkeel_pattern = ar.fatha + ar.sukun\n  results = pq.search_string_with_tashkeel(sentence,tashkeel_pattern)\n  print(results)\n\n  \n [(3, 5), (7, 9), (10, 12), (13, 15), (17, 19)]\n\n\n\n\nsearch_with_pattern\n\n\nsearch_with_pattern(pattern,sentence=None,verseNum=None,chapterNum=None,threshold=1)\n\n- this function use to search in 0's,1's pattern and return matched words from sentence pattern dependent on the    threshold, it takes a \npatter\n that you need to looking for , and \nsentence (optional)\n (sentence where will   search), \nchapterNum (opetional)\n and \nverseNum (opetional)\n and return list of matched words and sentences. \n\n\n- Cases: \n    1. if pass sentece only or with another args \n       it will search in sentece only.\n    2. if not passed sentence and passed verseNum and chapterNum,\n       it will search in this verseNum that exist in chapterNum only.\n    3. if not passed sentence,verseNum and passed chapterNum only,\n       it will search in this specific chapter only\n\n  * Note : it's takes time dependent on your threshold and size of chapter, so it's not support to search on All-Quran becouse it take very long time more than 11 min.\n\n\n\n\n  result = pq.search_with_pattern(pattern=\n01111\n,chapterNum=1,threshold=0.9)\n  print(result)\n\n  \n['\u0627\u0644\u0631\u0651\u064e\u062d\u0650\u064a\u0645\u0650 \u0645\u064e\u0644\u0650\u0643\u0650', '\u0646\u064e\u0639\u0652\u0628\u064f\u062f\u064f \u0648\u064e\u0625\u0650\u064a\u0651\u064e\u0627\u0643\u064e', '\u0627\u0644\u0652\u0645\u064f\u0633\u0652\u062a\u064e\u0642\u0650\u064a\u0645\u064e \u0635\u0650\u0631\u064e\u0637\u064e']", 
            "title": "\u062a\u0647\u0628\u064a\u062f"
        }, 
        {
            "location": "/methods guide/#thbeed", 
            "text": "Features  Imporatan information  Usage  Functions  Access functions \n    [x] DONE  Manipulate functions  separate_token_with_diacritics  get_tashkeel_binary  unpack_alef_mad  shape  check_all_alphabet  buckwalter_transliteration  extract_tashkeel    Analysis functions  count_shape  count_token  frequency_of_character    generate_frequancy_dictionary  sort_dictionary_by_similarity  check_sura_with_frequency  generate_latex_table    Search functions  search_sequence  search_string_with_tashkeel  search_with_pattern", 
            "title": "Thbeed"
        }, 
        {
            "location": "/methods guide/#features", 
            "text": "Access Holy-Quran :  get  Chapter  with/without diacritics.  get  Verse  with/without diacritics.  get  Token  (word).  get  Chapter name  ,  Chapter number .  get  Verses number  in verse.    Manipulate with Holy-Quran :  Separate to  letters  with/without diacritics.  Apply your  System  on Quran.  get  Binary representation  of Holy-Quran as 0's , 1's.  Extract  Taskill  from sentence.   Dealing with linguistic rules like :  Transfer Alef-mad  \"\u0622\"  to \"\u0623\u064e\u0623\u0652\"     Convert the  unicode of arabic  text to  buckwalter encoding  and vice versa  Convert Quran to  buckwalter reprsentation  and vice versa.     Analysis Holy-Quran:  get  Frequency Matrix  of letters dependent on Applied  alphabet system .  get  Frequency dictionary  of tokens.  sort  Frequency dictionary  using similarity threshold.    Search in Holy-Quran using :  Text  and ther is a variety options.  diacritics pattern .   binary representation pattern  using threshold.", 
            "title": "Features"
        }, 
        {
            "location": "/methods guide/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/methods guide/#manipulate-functions", 
            "text": "", 
            "title": "Manipulate functions:"
        }, 
        {
            "location": "/methods guide/#separate_token_with_diacritics", 
            "text": "separate_token_with_diacritics(sentence) \n- takes  sentence  and separate it to characters with there diacritics.    wordSeparated = pq.separate_token_with_dicrites('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\n  print(wordSeparated)\n\n    ['\u0625\u0650', '\u0646\u0651\u064e', '\u0627', ' ', '\u0623\u064e', '\u0639\u0652', '\u0637\u064e', '\u064a\u0652', '\u0646\u064e', '\u0643\u064e', ' ', '\u0627', '\u0644\u0652', '\u0643\u064e', '\u0648\u0652', '\u062b\u064e', '\u0631\u064e']", 
            "title": "separate_token_with_diacritics"
        }, 
        {
            "location": "/methods guide/#get_tashkeel_binary", 
            "text": "get_tashkeel_binary(verse) \n- takes the verses content or chapters with diacritics and it returns tuple of the mapping of  chracters with diacritics  to  0's,1's  and  harakah  represented as  1  and  sukun  represented as  0  and return list of diacritics too.    pattern = pq.get_tashkeel_binary('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\n  print(pattern)\n\n    ('1010 101011 001011', ['\u0650', '\u0652', '\u064e', '', '', '\u064e', '\u0652', '\u064e', '\u0652', '\u064e', '\u064e', '', '', '\u0652', '\u064e', '\u0652', '\u064e', '\u064e'])", 
            "title": "get_tashkeel_binary"
        }, 
        {
            "location": "/methods guide/#unpack_alef_mad", 
            "text": "unpack_alef_mad(ayahWithAlefMad) \n- takes  ayahWithAlefMad  (sentence that has Alef-Mad) and it returns the sentence after replace  Alef-mad  to  Alef-hamza-above + fatha  and  alef-hamza-above + sukun .    unpackAlefMad = pq.unpack_alef_mad('\u0622')\n  print(unpackAlefMad)\n\n    '\u0623\u0652\u0623\u064e'", 
            "title": "unpack_alef_mad"
        }, 
        {
            "location": "/methods guide/#buckwalter_transliteration", 
            "text": "buckwalter_transliteration(sentence, reverse) \n- takes an  sentence  and  reverse (optional)  the trnslate option if  True  convert  sentence  from Arabic to BuckWalter and if  False (default)  convert  sentence  from BuckWalter to Arabic.", 
            "title": "buckwalter_transliteration"
        }, 
        {
            "location": "/methods guide/#notethe-encoding-with-diacritics-is-different-from-without-diacritics", 
            "text": "buckwalterEncode = pq.buckwalter_transliteration('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\n  print(buckwalterEncode)\n\n     in~aA  aEoTayonaka Alokawovara", 
            "title": "note:the encoding with diacritics is  different from without diacritics**."
        }, 
        {
            "location": "/methods guide/#analysis-functions", 
            "text": "", 
            "title": "Analysis functions:"
        }, 
        {
            "location": "/methods guide/#count_shape", 
            "text": "count_shape(text, system=None) \n- takes  text  (chapter/verse),  system (optional)  it's the shape of character as example [[bah,gem]] and return a  n*p matrix  where  n  number of verses and  p  number of collections in system and if not pass system it will apply the defualt.      newSystem=[[beh, teh, theh], [jeem, hah, khah]]\n  alphabetAsOneShape =pq.count_shape(get_sura(110), newSystem)\n  print(alphabetAsOneShape)\n\n    [[1 2 1 0 0 0 1 0 4 0 0 1 1 0 0 0 1 0 0 0 0 0 1 0 0 3 0 1 1 1 0 0]\n       [1 2 0 0 2 0 0 0 5 0 2 0 1 0 1 0 0 0 0 0 0 0 2 0 0 4 0 3 1 3 1 3]\n       [6 2 0 0 0 0 1 0 4 0 1 0 2 0 2 0 0 0 0 0 0 1 2 0 2 0 1 2 2 2 0 0]]", 
            "title": "count_shape"
        }, 
        {
            "location": "/methods guide/#count_token", 
            "text": "count_token(text)  \n- takes  text  (chapter/verse) and returns the number of tokens.", 
            "title": "count_token"
        }, 
        {
            "location": "/methods guide/#note-the-harf-is-not-calculated-as-token-alone", 
            "text": "numberOfToken=pq.count_token(tools.get_sura(110))\n  print(numberOfToken)\n\n    19", 
            "title": "note: the harf ('\u0648') is not calculated as token alone"
        }, 
        {
            "location": "/methods guide/#frequency_of_character", 
            "text": "frequency_of_character(characters,verse=None,chapterNum=0,verseNum=0,with_tashkeel=False) \n- takes  characters  that you need to count , return dictionary that havecounts characters occurrence for verses or with chapter or even all quran and the dictionary contains the key char and values is an occurrence of character .\n- optional opptions: \n    -  verse  (str): if passed, it will applied to this string only \n    -  chapterNum  (int) : if passed only, it will applied to this chapter only.\n    -  verseNum  (int) :\n        - if passed only, it will applied to  verseNum  for  all Chapters .\n        - if passed with  chapterNum , it will applied to verseNum for  chapterNum .\n    -  with_tashkeel  (bool):\n        - if  True  applied to Quran  with  Tashkieel.\n        - if  False  applied to Quran  without  Tashkieel.\n- Note : if don't pass any   optional opptions  it will applied to all  Quran .    frequencyOfChar =tools.frequency_of_character(['\u0623','\u0628'],'\u0642\u0644 \u0623\u0639\u0648\u0630 \u0628\u0631\u0628 \u0627\u0644\u0646\u0627\u0633',114,1)\n  print(frequencyOfChar)\n\n    {\u0623:1,\u0628:2}", 
            "title": "frequency_of_character"
        }, 
        {
            "location": "/methods guide/#generate_frequancy_dictionary", 
            "text": "generate_frequency_dictionary(suraNumber=None)  \n- takes  suraNumber (optional)  the number of chapter and it returns the dictionary of  words contains the  word  as key and its  frequency  as value and if not pass  suraNumber  it will applied to  all-Quran .    dictionaryFrequency = pq.generate_frequency_dictionary(114)\n  print(dictionaryFrequency)\n\n    {'\u0627\u0644\u0646\u0627\u0633': 4, '\u0645\u0646': 2, '\u0642\u0644': 1, '\u0623\u0639\u0648\u0630': 1, '\u0628\u0631\u0628': 1, '\u0645\u0644\u0643': 1, '\u0625\u0644\u0647': 1, '\u0634\u0631': 1, '\u0627\u0644\u0648\u0633\u0648\u0627\u0633': 1, '\u0627\u0644\u062e\u0646\u0627\u0633': 1, '\u0627\u0644\u0630\u0649': 1, '\u064a\u0648\u0633\u0648\u0633': 1, '\u0641\u0649': 1, '\u0635\u062f\u0648\u0631': 1, '\u0627\u0644\u062c\u0646\u0629': 1, '\u0648\u0627\u0644\u0646\u0627\u0633': 1}", 
            "title": "generate_frequancy_dictionary"
        }, 
        {
            "location": "/methods guide/#sort_dictionary_by_similarity", 
            "text": "sort_dictionary_by_similarity(frequency_dictionary,threshold=0.8) \n- using to  cluster words  by using similarity  and sort every bunch of word  by most common and sort bunches descending in the same time takes the frequency dictionary generated using  generate_frequency_dictionary  function. This function takes dictionary of frequencies and  threshold (optional)  to specify  the degree of similarity      sortedDictionary = pq.sort_dictionary_by_similarity(dictionaryFrequency)\n  print(sortedDictionary)\n\n    {'\u0627\u0644\u0646\u0627\u0633': 4, '\u0627\u0644\u062e\u0646\u0627\u0633': 1, '\u0648\u0627\u0644\u0646\u0627\u0633': 1, '\u0645\u0646': 2, '\u0642\u0644': 1, '\u0623\u0639\u0648\u0630': 1, '\u0628\u0631\u0628': 1, '\u0645\u0644\u0643': 1, '\u0625\u0644\u0647': 1, '\u0634\u0631': 1, '\u0627\u0644\u0648\u0633\u0648\u0627\u0633': 1, '\u0627\u0644\u0630\u0649': 1, '\u064a\u0648\u0633\u0648\u0633': 1, '\u0641\u0649': 1, '\u0635\u062f\u0648\u0631': 1, '\u0627\u0644\u062c\u0646\u0629': 1}", 
            "title": "sort_dictionary_by_similarity"
        }, 
        {
            "location": "/methods guide/#check_sura_with_frequency", 
            "text": "check_sura_with_frequency(sura_num,freq_dec) \n- function checks if frequency dictionary of  specific chapter  is compatible with  original chapter  in quran, it takes  sura_num  (chapter number) and  freq_dec  (frequency dictionary) and return  True  if compatible and  False  in not.    dictionaryFrequency = pq.generate_frequency_dictionary(111)\n  matched = pq.check_sura_with_frequency(110,dictionaryFrequency)\n  print(matched)\n\n    False", 
            "title": "check_sura_with_frequency"
        }, 
        {
            "location": "/methods guide/#generate_latex_table", 
            "text": "generate_latex_table(dictionary,filename,location=\".\") \n- generates latex code of table of frequency it takes dictionary frequency ,it takes  dictionary  (frequency dictionary) ,  filename  and  location  (location to save) , the default location is same directory by symbol '.', then it returns  True  if the operation of generation completed successfully  False  if something wrong     latexTable = pq.generate_latex_table(dictionaryFrequency,'any_file_name')\n  print(latexTable)\n\n    True", 
            "title": "generate_latex_table"
        }, 
        {
            "location": "/methods guide/#search-functions", 
            "text": "", 
            "title": "Search functions"
        }, 
        {
            "location": "/methods guide/#search_sequence", 
            "text": "search_sequence(sequancesList,verse=None,chapterNum=0,verseNum=0,mode=3) \n- take list of sequances and return matched sequance, it search in verse ot chapter or All Quran,\n    - it return for every match :\n         - matched sequance \n         - chapter number of occurrence\n         - token number if word and 0 if sentence  - Note :\n     - if found verse != None it will use it en search .    \n     - if no verse and found chapterNum and verseNum it will use this verse and use it to search.\n     - if no verse and no verseNum and found chapterNum it will search in chapter.\n     - if no verse and no chapterNum and no verseNum it will search in All Quran.\n\n- it has many modes:\n    1. search with decorated sequance (with tashkeel), and return matched sequance with decorates (with tashkil).\n    2. search without decorated sequance (without tashkeel), and return matched sequance without decorates (without tashkil).\n    3. search without decorated sequance (without tashkeel), and return matched sequance with decorates (with tashkil).\n\n\n- optional opptions: \n    - **verse** (str): if passed, it will applied to this string only \n    - **chapterNum** (int) : if passed only, it will applied to this chapter only.\n    - **verseNum** (int) :\n        - if passed only, it will applied to **verseNum** for **all Chapters**.\n        - if passed with **chapterNum**, it will applied to verseNum for **chapterNum**.\n    - **with_tashkeel** (bool):\n        - if **True** applied to Quran **with** Tashkieel.\n        - if **False** applied to Quran **without** Tashkieel.\n        - mode (int): this mode that you need to use and default mode 3\n\n- Note : if don't pass any  **optional opptions** it will applied to all **Quran**.\n- Returns: dict() : key is sequances and value is a list of matched_sequance and their positions    matchedKeyword = pq.search_sequence(['\u0642\u0644 \u0623\u0639\u0648\u0630 \u0628\u0631\u0628'])\n  print(matchedKeyword)\n\n    {'\u0642\u0644 \u0623\u0639\u0648\u0630 \u0628\u0631\u0628': [('\u0642\u064f\u0644\u0652 \u0623\u064e\u0639\u064f\u0648\u0630\u064f \u0628\u0650\u0631\u064e\u0628\u0651\u0650', 0, 1, 113), ('\u0642\u064f\u0644\u0652 \u0623\u064e\u0639\u064f\u0648\u0630\u064f \u0628\u0650\u0631\u064e\u0628\u0651\u0650', 0, 1, 114)]}", 
            "title": "search_sequence"
        }, 
        {
            "location": "/methods guide/#search_string_with_tashkeel", 
            "text": "search_string_with_tashkeel(sentence,tashkeel_pattern) \n- takes an  sentence  and  tashkeel_pattern  (composed of 0's , 1's) and it returns the locations that matched the pattern of diacrictics start index  inclusive  and end index  exculsive  and return empty list if not found.  \n  sentence = '\u0635\u0650\u0641\u0652 \u0630\u064e\u0627\u0652 \u062b\u064e\u0646\u064e\u0627\u0652 \u0643\u064e\u0645\u0652 \u062c\u064e\u0627\u0652\u062f\u064e \u0634\u064e\u062e\u0652\u0635\u064c'\n  tashkeel_pattern = ar.fatha + ar.sukun\n  results = pq.search_string_with_tashkeel(sentence,tashkeel_pattern)\n  print(results)\n\n    [(3, 5), (7, 9), (10, 12), (13, 15), (17, 19)]", 
            "title": "search_string_with_tashkeel"
        }, 
        {
            "location": "/methods guide/#search_with_pattern", 
            "text": "search_with_pattern(pattern,sentence=None,verseNum=None,chapterNum=None,threshold=1) \n- this function use to search in 0's,1's pattern and return matched words from sentence pattern dependent on the    threshold, it takes a  patter  that you need to looking for , and  sentence (optional)  (sentence where will   search),  chapterNum (opetional)  and  verseNum (opetional)  and return list of matched words and sentences.   - Cases: \n    1. if pass sentece only or with another args \n       it will search in sentece only.\n    2. if not passed sentence and passed verseNum and chapterNum,\n       it will search in this verseNum that exist in chapterNum only.\n    3. if not passed sentence,verseNum and passed chapterNum only,\n       it will search in this specific chapter only\n\n  * Note : it's takes time dependent on your threshold and size of chapter, so it's not support to search on All-Quran becouse it take very long time more than 11 min.  \n  result = pq.search_with_pattern(pattern= 01111 ,chapterNum=1,threshold=0.9)\n  print(result)\n\n   ['\u0627\u0644\u0631\u0651\u064e\u062d\u0650\u064a\u0645\u0650 \u0645\u064e\u0644\u0650\u0643\u0650', '\u0646\u064e\u0639\u0652\u0628\u064f\u062f\u064f \u0648\u064e\u0625\u0650\u064a\u0651\u064e\u0627\u0643\u064e', '\u0627\u0644\u0652\u0645\u064f\u0633\u0652\u062a\u064e\u0642\u0650\u064a\u0645\u064e \u0635\u0650\u0631\u064e\u0637\u064e']", 
            "title": "search_with_pattern"
        }, 
        {
            "location": "/maintainers/", 
            "text": "", 
            "title": "For maintainers"
        }
    ]
}