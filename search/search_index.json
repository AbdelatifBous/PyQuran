{
    "docs": [
        {
            "location": "/", 
            "text": "PyQuran: The Python package for Quranic Analysis\n\n\nPyQuran is a python package, that provides tools for \nQuranic Analysis\n.\n\n\nIt is still a small package which needs a lot of your effort. But, we think it is a seed of a fundamental general package for\ncomputations on \nQuran\n with Python, even at the most basic level which simply retrieving Quran text.\n\n\nBefore Islam\n, Arabic letters  were without  dots\u2014\n\nrasm\n, which resulted in ambiguty, two or three\nletters had the same rasm/form/shape/look. \n\n\nMuslims have decided to remove this ambiguity by adding\ndots above or below each letter of the ones which share the same rasm. Now each letter has a unique form. By the way,\noriginally, \nQuran\n was written without dots on the letters.\n\n\nTo enable you to use both modern system or other, we introduce \nalphabetical systems\n,\nIt is a dynamic construction of letters\u2014\n\nAlphabetical Systems\n.\n\n\nCurrent Features\n\n\n\n\nfetch chapters and verses.\n\n\nsearch Quran by text tokens and by diacritics patterns.\n\n\nbuckwalter transliteration, back and forth\n\n\nMultiple \nalphabetical systems\n, \nfor more details see the \nPyQuran Wiki\n\n\n\n\nInstall\n\n\n\n\nFrom \nPyPI\n: \n$ pip3 install pyquran\n\n\nFrom Source: \n$ python3 setup.py install\n\n\n\n\nDependencies\n\n\n\n\nnumpy\n\n\npyarabic\n\n\n\n\nQuran Corpus\n\n\nWe use \ntanzil\n Quran Corpus (\nUthmani Text\n), it is in \nUTF-8\n encoding. You\ncan find all unique characters of Uthmanic Corpus\n\nhere\n.\n\n\nThere are \nspecial recitation symbols\n \u0645\u0635\u0637\u0644\u062d\u0627\u062a \u0627\u0644\u0636\u0628\u0637 in the \nUthmani Text\n, they are a guide for the reciter\nto know the right positions to pause and the rules of tajweed.\nWe provide an interface to filter those symbols, \nonly the fly while fetching from the corpus\n,\nwe \nDO NOT\n change the corpus, NEVER.\n\n\nFor the full details about filtering \nspecial recitation symbols\n \u0645\u0635\u0637\u0644\u062d\u0627\u062a \u0627\u0644\u0636\u0628\u0637.\n\n\nContributing\n\n\nTo contribute and maintain \nPyQuran\n, Please read  \nCONTRIBUTING.md\n.\n\n\nSee also \nHow to contribute to PyQuran\n.\n\n\nCiting\n\n\nnot_completed_ (need to disscuss it with the prof.)\nCite \nPyQuran\n as the following \nBibTeX\n entry.\n\n\n@MISC {PyQuran2018,\nauthor             = \nWaleed A. Yousef\n,\ntitle              = \nPyQuran\n,\nhowpublished       = \nhttps://github.com/TahaMagdy/PyQuran\n,\nmonth              = \nfeb\n,\nyear               = \n2018\n\n}\n\n\n\n\nCommunication\n\n\n\u0640not_completed_\n\n\nLicence\n\n\nnot_completed_ (need to discuss it with the prof.)", 
            "title": "PyQuran: The Python package for Quranic Analysis"
        }, 
        {
            "location": "/#pyquran-the-python-package-for-quranic-analysis", 
            "text": "PyQuran is a python package, that provides tools for  Quranic Analysis .  It is still a small package which needs a lot of your effort. But, we think it is a seed of a fundamental general package for\ncomputations on  Quran  with Python, even at the most basic level which simply retrieving Quran text.  Before Islam , Arabic letters  were without  dots\u2014 rasm , which resulted in ambiguty, two or three\nletters had the same rasm/form/shape/look.   Muslims have decided to remove this ambiguity by adding\ndots above or below each letter of the ones which share the same rasm. Now each letter has a unique form. By the way,\noriginally,  Quran  was written without dots on the letters.  To enable you to use both modern system or other, we introduce  alphabetical systems ,\nIt is a dynamic construction of letters\u2014 Alphabetical Systems .", 
            "title": "PyQuran: The Python package for Quranic Analysis"
        }, 
        {
            "location": "/#current-features", 
            "text": "fetch chapters and verses.  search Quran by text tokens and by diacritics patterns.  buckwalter transliteration, back and forth  Multiple  alphabetical systems ,  for more details see the  PyQuran Wiki", 
            "title": "Current Features"
        }, 
        {
            "location": "/#install", 
            "text": "From  PyPI :  $ pip3 install pyquran  From Source:  $ python3 setup.py install", 
            "title": "Install"
        }, 
        {
            "location": "/#dependencies", 
            "text": "numpy  pyarabic", 
            "title": "Dependencies"
        }, 
        {
            "location": "/#quran-corpus", 
            "text": "We use  tanzil  Quran Corpus ( Uthmani Text ), it is in  UTF-8  encoding. You\ncan find all unique characters of Uthmanic Corpus here .  There are  special recitation symbols  \u0645\u0635\u0637\u0644\u062d\u0627\u062a \u0627\u0644\u0636\u0628\u0637 in the  Uthmani Text , they are a guide for the reciter\nto know the right positions to pause and the rules of tajweed.\nWe provide an interface to filter those symbols,  only the fly while fetching from the corpus ,\nwe  DO NOT  change the corpus, NEVER.  For the full details about filtering  special recitation symbols  \u0645\u0635\u0637\u0644\u062d\u0627\u062a \u0627\u0644\u0636\u0628\u0637.", 
            "title": "Quran Corpus"
        }, 
        {
            "location": "/#contributing", 
            "text": "To contribute and maintain  PyQuran , Please read   CONTRIBUTING.md .  See also  How to contribute to PyQuran .", 
            "title": "Contributing"
        }, 
        {
            "location": "/#citing", 
            "text": "not_completed_ (need to disscuss it with the prof.)\nCite  PyQuran  as the following  BibTeX  entry.  @MISC {PyQuran2018,\nauthor             =  Waleed A. Yousef ,\ntitle              =  PyQuran ,\nhowpublished       =  https://github.com/TahaMagdy/PyQuran ,\nmonth              =  feb ,\nyear               =  2018 \n}", 
            "title": "Citing"
        }, 
        {
            "location": "/#communication", 
            "text": "\u0640not_completed_", 
            "title": "Communication"
        }, 
        {
            "location": "/#licence", 
            "text": "not_completed_ (need to discuss it with the prof.)", 
            "title": "Licence"
        }, 
        {
            "location": "/Alphabetical-Systems/", 
            "text": "What do we mean by Alphabetical Systems?!", 
            "title": "Alphabetical Systems"
        }, 
        {
            "location": "/CONTRIBUTING/", 
            "text": "Contributing to PyQuran\n\n\nWe use GitHub issues for reporting bugs and for feature requests.\n\n\nIf you want to give us a hand, you may pick one of the opened issues and solve a bug, implement a feature request\nor to suggest a new missing feature.\n\n\nReporting issues\n\n\nWhen reporting a bug, use GitHub issue with the \nBug label\n, please include  as \nmuch details as possible about:\n- your operating system.\n- your python version.\n- a self-contained code to reproduce and demonstrate the Bug.\n\n\nIssue will be closed if the Bug cannot be reproduced.\n\n\nFeature Request\n\n\nWhenever you think \nPyQuran\n is missing a feature, create a GitHub issue with \nFeature Request label\n,\ndefine what you want precisely and include sufficient examples to cover all the new feature aspects.\n\n\nIf you would like to implement it by yourself, please read the \nContributing Code\n section.\n\n\nContributing Code\n\n\n_not_completed\n\n\ncode conventions\n\n\nYour code have to meet \nthese standartds\n,\nand follow \nthis style\n.\n\n\ncontributing flow\n\n\nAt first, fork the project \non GitHub\n,\nthen, create a \nfeature branch\n and start writing your changes. \nWe \nDO NOT\n accept changes to the \nmaster branch\n.\n\n\nOnce you are done, push the changes to \nyour feature branch\n, after that create a \npull request\n\nwith an expressive title and description.\n\n\ncommit messages\n\n\nIt is so important to commit properly\n, we expect you to commit every one logical change.\nA commit message should describe what have been changed, why, and reference issues fixed (if\nany). \n\n\nCommit Message Properties\n:\n1. The Fist line is the commit title, should be less then or equal 50 characters, it must be expressive.\n2. Keep the second line blank.\n3. Wrap all other lines in the message body at 80 columns.\n4. Include \nFixes #N\n, where \nN\n is the issue number the commit\n    fixes, if any.\n\n\nCommits should look like the following:\n\n\nexplain commit in one line\n\nBody of commit message is a few lines of text, explaining things\nin more detail, possibly giving some background about the issue\nbeing fixed, etc.\n\nThe body of the commit message **can be several paragraphs**, and\nplease do proper word-wrap and keep columns shorter than about\n80 characters.\n\nFixes #101\n\n\n\n\nTests\n\n\n_not_completed", 
            "title": "CONTRIBUTING"
        }, 
        {
            "location": "/CONTRIBUTING/#contributing-to-pyquran", 
            "text": "We use GitHub issues for reporting bugs and for feature requests.  If you want to give us a hand, you may pick one of the opened issues and solve a bug, implement a feature request\nor to suggest a new missing feature.", 
            "title": "Contributing to PyQuran"
        }, 
        {
            "location": "/CONTRIBUTING/#reporting-issues", 
            "text": "When reporting a bug, use GitHub issue with the  Bug label , please include  as \nmuch details as possible about:\n- your operating system.\n- your python version.\n- a self-contained code to reproduce and demonstrate the Bug.  Issue will be closed if the Bug cannot be reproduced.", 
            "title": "Reporting issues"
        }, 
        {
            "location": "/CONTRIBUTING/#feature-request", 
            "text": "Whenever you think  PyQuran  is missing a feature, create a GitHub issue with  Feature Request label ,\ndefine what you want precisely and include sufficient examples to cover all the new feature aspects.  If you would like to implement it by yourself, please read the  Contributing Code  section.", 
            "title": "Feature Request"
        }, 
        {
            "location": "/CONTRIBUTING/#contributing-code", 
            "text": "_not_completed", 
            "title": "Contributing Code"
        }, 
        {
            "location": "/CONTRIBUTING/#code-conventions", 
            "text": "Your code have to meet  these standartds ,\nand follow  this style .", 
            "title": "code conventions"
        }, 
        {
            "location": "/CONTRIBUTING/#contributing-flow", 
            "text": "At first, fork the project  on GitHub ,\nthen, create a  feature branch  and start writing your changes. \nWe  DO NOT  accept changes to the  master branch .  Once you are done, push the changes to  your feature branch , after that create a  pull request \nwith an expressive title and description.", 
            "title": "contributing flow"
        }, 
        {
            "location": "/CONTRIBUTING/#commit-messages", 
            "text": "It is so important to commit properly , we expect you to commit every one logical change.\nA commit message should describe what have been changed, why, and reference issues fixed (if\nany).   Commit Message Properties :\n1. The Fist line is the commit title, should be less then or equal 50 characters, it must be expressive.\n2. Keep the second line blank.\n3. Wrap all other lines in the message body at 80 columns.\n4. Include  Fixes #N , where  N  is the issue number the commit\n    fixes, if any.  Commits should look like the following:  explain commit in one line\n\nBody of commit message is a few lines of text, explaining things\nin more detail, possibly giving some background about the issue\nbeing fixed, etc.\n\nThe body of the commit message **can be several paragraphs**, and\nplease do proper word-wrap and keep columns shorter than about\n80 characters.\n\nFixes #101", 
            "title": "commit messages"
        }, 
        {
            "location": "/CONTRIBUTING/#tests", 
            "text": "_not_completed", 
            "title": "Tests"
        }, 
        {
            "location": "/DOCUMENTATION/", 
            "text": "Documentation\n\n\n\n\nFeatures\n\n\nImporatan information\n\n\nUsage\n\n\nFunctions\n\n\nAccess functions\n\n\nget_sura\n\n\nget_verse\n\n\nget_token\n\n\nget_sura_number\n\n\nget_sura_name\n\n\nget_verse_count\n\n\n\n\n\n\nManipulate functions\n\n\nseparate_token_with_diacritics\n\n\nget_tashkeel_binary\n\n\nunpack_alef_mad\n\n\nshape\n\n\ncheck_system\n\n\ncheck_all_alphabet\n\n\nbuckwalter_transliteration\n\n\nextract_tashkeel\n\n\n\n\n\n\nAnalysis functions\n\n\ncount_shape\n\n\ncount_token\n\n\nfrequency_of_character\n \n\n\ngenerate_frequancy_dictionary\n\n\nsort_dictionary_by_similarity\n\n\ncheck_sura_with_frequency\n\n\ngenerate_latex_table\n\n\n\n\n\n\nSearch functions\n\n\nsearch_sequence\n\n\nsearch_string_with_tashkeel\n\n\nsearch_with_pattern\n\n\n\n\n\n\n\n\n\n\n\n\nFeatures\n\n\n\n\nAccess Holy-Quran :\n\n\nget \nChapter\n with/without diacritics.\n\n\nget \nVerse\n with/without diacritics.\n\n\nget \nToken\n (word).\n\n\nget \nChapter name\n , \nChapter number\n.\n\n\nget \nVerses number\n in verse.\n\n\n\n\n\n\nManipulate with Holy-Quran :\n\n\nSeparate to \nletters\n with/without diacritics.\n\n\nApply your \nSystem\n on Quran.\n\n\nget \nBinary representation\n of Holy-Quran as 0's , 1's.\n\n\nExtract \nTaskill\n from sentence. \n\n\nDealing with linguistic rules like :\n\n\nTransfer Alef-mad \n\"\u0622\"\n to \"\u0623\u064e\u0623\u0652\" \n\n\n\n\n\n\nConvert the \nunicode of arabic\n text to \nbuckwalter encoding\n and vice versa\n\n\nConvert Quran to \nbuckwalter reprsentation\n and vice versa. \n\n\n\n\n\n\nAnalysis Holy-Quran:\n\n\nget \nFrequency Matrix\n of letters dependent on Applied \nalphabet system\n.\n\n\nget \nFrequency dictionary\n of tokens.\n\n\nsort \nFrequency dictionary\n using similarity threshold.\n\n\n\n\n\n\nSearch in Holy-Quran using :\n\n\nText\n and ther is a variety options.\n\n\ndiacritics pattern\n. \n\n\nbinary representation pattern\n using threshold.\n\n\n\n\n\n\n\n\nImporatan information\n\n\n\n\nNote all verses/chapters/tokens start with \n1\n not \n0\n\n\n\n\nAlphaSystem :\n\n\nit's collection of Alphabits that you can apply it on Quran as you need, where you can treat many characters as one character, like:\n\n\nsystem = [['\u0623','\u0622','\u0625'],['\u062a','\u0628']]\n\n\n\n\nhere we treat \n['\u0623','\u0622','\u0625']\n as one character and \n['\u062a','\u0628']\n as another one and the \nres characters\n every one treat as one, this system applied to all functions in \nPyQuran\n in Counting,Search,Filltering ...etc. \n\n\nthe default system used in library treat every character as one , you will find some of \npre-defined\n parts of system that you can use it to define your system , import \nsystems\n to use them.\n\n\n\n\npre-defined:\n\n\nwithoutDotSystem (treat all characters has dot as one)\n\n\nhamazatSystem (treat all characters has hamza as one)\n\n\n\n\n\n\n\n\nfrom pyquran import systems\nsystem = [['\u062a','\u0628'], systems.hamazatSystem]\n\n\n\n\nUsage\n\n\n   import PyQuran as pq\n\n\n\n\nFunctions\n\n\nAccess functions:\n\n\nget_sura\n\n\nget_sura(chapter_num,with_tashkeil)\n\n- takes \nchapter_num\n it's the number of surah and returns \nlist of chapter verses\n and the \nwith_tashkeil (optional)\n is the diacritics option and if \nTrue\n return chapter with diacritics and if \nFalse\n return without and defualt \nfalse\n .\n\n\n  sura = pq.get_sura(108,True)\n  print(sura)\n\n  \n ['\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e', '\u0641\u064e\u0635\u064e\u0644\u0651\u0650 \u0644\u0650\u0631\u064e\u0628\u0651\u0650\u0643\u064e \u0648\u064e\u0627\u0646\u0652\u062d\u064e\u0631\u0652', '\u0625\u0650\u0646\u0651\u064e \u0634\u064e\u0627\u0646\u0650\u0626\u064e\u0643\u064e \u0647\u064f\u0648\u064e \u0627\u0644\u0652\u0623\u064e\u0628\u0652\u062a\u064e\u0631\u064f']\n\n\n\n\nget_verse\n\n\nget_verse(chapter_num,verse_num,with_tashkeel)\n \n- takes the \nchapter_num\n , \nverse_num\n and and it return \nverse content\n and \nwith_tashkeil (optional)\n is the diacritics option and if \nTrue\n return verses with diacritics and if \nFalse\n return without and defualt \nfalse\n.\n\n\n  ayahText=pq.get_verse(110,1,True)\n  print(ayahText)\n\n  \n \u0625\u0650\u0630\u064e\u0627 \u062c\u064e\u0627\u0621\u064e \u0646\u064e\u0635\u0652\u0631\u064f \u0627\u0644\u0644\u0651\u064e\u0647\u0650 \u0648\u064e\u0627\u0644\u0652\u0641\u064e\u062a\u0652\u062d\u064f\n\n\n\n\nget_token\n\n\nget_token(token_num , verse_num , chapter_num , with_tashkeel)\n \n- takes the \ntoken_num\n (position Of Token) , \nverse_num\n , \nchapter_num\n and it return \ntoken\n  and \nwith_tashkeil (optional)\n is the diacritics option and if \nTrue\n return token with diacritics and if \nFalse\n return without and defualt \nfalse\n .\n\n\n  tokenText = pq.get_token(4,1,114,True)\n  print(tokenText)\n\n  \n \u0627\u0644\u0646\u0651\u064e\u0627\u0633\u0650\n\n\n\n\nget_sura_number\n\n\nget_sura_number(chapter_name)\n\n- takes the name of chapter and return it's number.\n\n\n  suraNumber = pq.get_sura_number('\u0627\u0644\u0645\u0644\u0643')\n  print(suraNumber)\n\n  \n 67\n\n\n\n\nget_sura_name\n\n\nget_sura_name(chapter_num)\n \n- takes the number of chapter and return it's.\n\n\n  suraName = pq.get_sura_name(67)\n  print(suraName)\n\n  \n \u0627\u0644\u0645\u0644\u0643\n\n\n\n\nget_verse_count\n\n\nget_verse_count(chapter)\n\n- takes \nchapter\n and return the number of verses.\n\n\n  numberOfAyat = pd.get_verse_count(pq.get_sura(110,True))\n  print(numberOfAyat)\n\n  \n 3\n\n\n\n\nManipulate functions:\n\n\nseparate_token_with_diacritics\n\n\nseparate_token_with_diacritics(sentence)\n\n- takes \nsentence\n and separate it to characters with there diacritics.\n\n\n  wordSeparated = pq.separate_token_with_dicrites('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\n  print(wordSeparated)\n\n  \n ['\u0625\u0650', '\u0646\u0651\u064e', '\u0627', ' ', '\u0623\u064e', '\u0639\u0652', '\u0637\u064e', '\u064a\u0652', '\u0646\u064e', '\u0643\u064e', ' ', '\u0627', '\u0644\u0652', '\u0643\u064e', '\u0648\u0652', '\u062b\u064e', '\u0631\u064e']\n\n\n\n\nget_tashkeel_binary\n\n\nget_tashkeel_binary(verse)\n\n- takes the verses content or chapters with diacritics and it returns tuple of the mapping of \nchracters with diacritics\n to \n0's,1's\n and \nharakah\n represented as \n1\n and \nsukun\n represented as \n0\n and return list of diacritics too.\n\n\n  pattern = pq.get_tashkeel_binary('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\n  print(pattern)\n\n  \n ('1010 101011 001011', ['\u0650', '\u0652', '\u064e', '', '', '\u064e', '\u0652', '\u064e', '\u0652', '\u064e', '\u064e', '', '', '\u0652', '\u064e', '\u0652', '\u064e', '\u064e'])\n\n\n\n\n\nunpack_alef_mad\n\n\nunpack_alef_mad(ayahWithAlefMad)\n\n- takes \nayahWithAlefMad\n (sentence that has Alef-Mad) and it returns the sentence after replace \nAlef-mad\n to \nAlef-hamza-above + fatha\n and \nalef-hamza-above + sukun\n.\n\n\n  unpackAlefMad = pq.unpack_alef_mad('\u0622')\n  print(unpackAlefMad)\n\n  \n '\u0623\u0652\u0623\u064e'\n\n\n\n\nshape\n\n\nshape(system)\n\n- takes \nsystem\n (a new system for alphabets) ,system is \"\na list of lists\n\" that want to treat every \"\ninner list\n\" as one character and returns a dictionary has the same value for each set of alphabets and diffirent values for the rest of alphabets , you can see to more details \nhere\n.\n\n\n  newSystem = [[pq.beh, pq.teh], [pq.jeem, pq.hah, pq.khah]]\n  updatedSystem = pq.shape(newSystem)\n  print(updatedSystem)\n\n  \n {'\u0628': 0, '\u062a': 0, '\u062b': 0, '\u062c': 1, '\u062d': 1, '\u062e': 1, '\u0621': 2, '\u0622': 3, '\u0623': 4, '\u0624': 5, '\u0625': 6, '\u0626': 7, '\u0627': 8, '\u0629': 9, '\u062f': 10, '\u0630': 11, '\u0631': 12, '\u0632': 13, '\u0633': 14, '\u0634': 15, '\u0635': 16, '\u0636': 17, '\u0637': 18, '\u0638': 19, '\u0639': 20, '\u063a': 21, '\u0641': 22, '\u0642': 23, '\u0643': 24, '\u0644': 25, '\u0645': 26, '\u0646': 27, '\u0647': 28, '\u0648': 29, '\u0649': 30, '\u064a': 31, ' ': 70}\n\n\n\n\ncheck_all_alphabet\n\n\ncheck_all_alphabet(system)\n\n- takes \nsystem\n and return the rest of default alphabet chracters that doesn't include \nsystem\n.\n\n\n  system = [[pq.beh, pq.teh], [pq.jeem, pq.hah, pq.khah]]\n  rest = pq.check_all_alphabet(system)\n  print(rest)\n\n  \n ['\u0621', '\u0622', '\u0623', '\u0624', '\u0625', '\u0626', '\u0627', '\u0629', '\u062b', '\u062f', '\u0630', '\u0631', '\u0632', '\u0633', '\u0634', '\u0635', '\u0636', '\u0637', '\u0638', '\u0639', '\u063a', '\u0641', '\u0642', '\u0643', '\u0644', '\u0645', '\u0646', '\u0647', '\u0648', '\u0649', '\u064a']\n\n\n\n\ncheck_system\n\n\ndef check_system(system, indx=None)\n\n- takes \nsystem\n and return main system after apply new system and takes too \nindex (optional)\n that return specific collection from main system.  \n\n\n  # without index\n  system = [[pq.beh, pq.teh], [pq.jeem, pq.hah, pq.khah]]\n  rest = pq.check_system(system)\n  print(rest)\n\n  \n [['\u0628', '\u062a'], ['\u062c', '\u062d', '\u062e'], ['\u0621'], ['\u0622'], ['\u0623'], ['\u0624'], ['\u0625'], ['\u0626'], ['\u0627'], ['\u0629'], ['\u062b'], ['\u062f'], ['\u0630'], ['\u0631'], ['\u0632'], ['\u0633'], ['\u0634'], ['\u0635'], ['\u0636'], ['\u0637'], ['\u0638'], ['\u0639'], ['\u063a'], ['\u0641'], ['\u0642'], ['\u0643'], ['\u0644'], ['\u0645'], ['\u0646'], ['\u0647'], ['\u0648'], ['\u0649'], ['\u064a']]\n\n\n  # with index\n  system = [[pq.beh, pq.teh], [pq.jeem, pq.hah, pq.khah]]\n  rest = pq.check_system(system,index=1)\n  print(rest)\n\n  \n ['\u062c', '\u062d', '\u062e']\n ```\n\n\n#### buckwalter_transliteration\n**buckwalter_transliteration(sentence, reverse)**\n- takes an **sentence** and **reverse (optional)** the trnslate option if **True** convert **sentence** from Arabic to BuckWalter and if **False (default)** convert **sentence** from BuckWalter to Arabic.\n\n##### note**:the encoding with **diacritics** is  different from **without diacritics**.\n\n```python\n  buckwalterEncode = pq.buckwalter_transliteration('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\n  print(buckwalterEncode)\n\n  \n \nin~aA \naEoTayonaka Alokawovara\n\n\n\n\nextract_tashkeel\n\n\nextract_tashkeel(sentence)\n\n- takes an \nsentence\n and return the tashleel only without charaters.\n\nComming soooooon =D .....Taha Magedy Note\n\n\nAnalysis functions:\n\n\ncount_shape\n\n\ncount_shape(text, system=None)\n\n- takes \ntext\n (chapter/verse), \nsystem (optional)\n it's the shape of character as example [[bah,gem]] and return a \nn*p matrix\n where \nn\n number of verses and \np\n number of collections in system and if not pass system it will apply the defualt.  \n\n\n  newSystem=[[beh, teh, theh], [jeem, hah, khah]]\n  alphabetAsOneShape =pq.count_shape(get_sura(110), newSystem)\n  print(alphabetAsOneShape)\n\n  \n [[1 2 1 0 0 0 1 0 4 0 0 1 1 0 0 0 1 0 0 0 0 0 1 0 0 3 0 1 1 1 0 0]\n       [1 2 0 0 2 0 0 0 5 0 2 0 1 0 1 0 0 0 0 0 0 0 2 0 0 4 0 3 1 3 1 3]\n       [6 2 0 0 0 0 1 0 4 0 1 0 2 0 2 0 0 0 0 0 0 1 2 0 2 0 1 2 2 2 0 0]]\n\n\n\n\ncount_token\n\n\ncount_token(text)\n \n- takes \ntext\n (chapter/verse) and returns the number of tokens.\n\n\nnote\n: the harf ('\u0648') is not calculated as token alone\n\n\n  numberOfToken=pq.count_token(tools.get_sura(110))\n  print(numberOfToken)\n\n  \n 19\n\n\n\n\nfrequency_of_character\n\n\nfrequency_of_character(characters,verse=None,chapterNum=0,verseNum=0,with_tashkeel=False)\n\n- takes \ncharacters\n that you need to count , return dictionary that havecounts characters occurrence for verses or with chapter or even all quran and the dictionary contains the key char and values is an occurrence of character .\n- optional opptions: \n    - \nverse\n (str): if passed, it will applied to this string only \n    - \nchapterNum\n (int) : if passed only, it will applied to this chapter only.\n    - \nverseNum\n (int) :\n        - if passed only, it will applied to \nverseNum\n for \nall Chapters\n.\n        - if passed with \nchapterNum\n, it will applied to verseNum for \nchapterNum\n.\n    - \nwith_tashkeel\n (bool):\n        - if \nTrue\n applied to Quran \nwith\n Tashkieel.\n        - if \nFalse\n applied to Quran \nwithout\n Tashkieel.\n- Note : if don't pass any  \noptional opptions\n it will applied to all \nQuran\n.\n\n\n  frequencyOfChar =tools.frequency_of_character(['\u0623','\u0628'],'\u0642\u0644 \u0623\u0639\u0648\u0630 \u0628\u0631\u0628 \u0627\u0644\u0646\u0627\u0633',114,1)\n  print(frequencyOfChar)\n\n  \n {\u0623:1,\u0628:2}\n\n\n\n\ngenerate_frequancy_dictionary\n\n\ngenerate_frequency_dictionary(suraNumber=None)\n \n- takes \nsuraNumber (optional)\n the number of chapter and it returns the dictionary of  words contains the \nword\n as key and its \nfrequency\n as value and if not pass \nsuraNumber\n it will applied to \nall-Quran\n.\n\n\n  dictionaryFrequency = pq.generate_frequency_dictionary(114)\n  print(dictionaryFrequency)\n\n  \n {'\u0627\u0644\u0646\u0627\u0633': 4, '\u0645\u0646': 2, '\u0642\u0644': 1, '\u0623\u0639\u0648\u0630': 1, '\u0628\u0631\u0628': 1, '\u0645\u0644\u0643': 1, '\u0625\u0644\u0647': 1, '\u0634\u0631': 1, '\u0627\u0644\u0648\u0633\u0648\u0627\u0633': 1, '\u0627\u0644\u062e\u0646\u0627\u0633': 1, '\u0627\u0644\u0630\u0649': 1, '\u064a\u0648\u0633\u0648\u0633': 1, '\u0641\u0649': 1, '\u0635\u062f\u0648\u0631': 1, '\u0627\u0644\u062c\u0646\u0629': 1, '\u0648\u0627\u0644\u0646\u0627\u0633': 1}\n\n\n\n\nsort_dictionary_by_similarity\n\n\nsort_dictionary_by_similarity(frequency_dictionary,threshold=0.8)\n\n- using to \ncluster words  by using similarity\n and sort every bunch of word  by most common and sort bunches descending in the same time takes the frequency dictionary generated using \ngenerate_frequency_dictionary\n function. This function takes dictionary of frequencies and \nthreshold (optional)\n to specify \nthe degree of similarity\n \n\n\n  sortedDictionary = pq.sort_dictionary_by_similarity(dictionaryFrequency)\n  print(sortedDictionary)\n\n  \n {'\u0627\u0644\u0646\u0627\u0633': 4, '\u0627\u0644\u062e\u0646\u0627\u0633': 1, '\u0648\u0627\u0644\u0646\u0627\u0633': 1, '\u0645\u0646': 2, '\u0642\u0644': 1, '\u0623\u0639\u0648\u0630': 1, '\u0628\u0631\u0628': 1, '\u0645\u0644\u0643': 1, '\u0625\u0644\u0647': 1, '\u0634\u0631': 1, '\u0627\u0644\u0648\u0633\u0648\u0627\u0633': 1, '\u0627\u0644\u0630\u0649': 1, '\u064a\u0648\u0633\u0648\u0633': 1, '\u0641\u0649': 1, '\u0635\u062f\u0648\u0631': 1, '\u0627\u0644\u062c\u0646\u0629': 1}\n\n\n\n\ncheck_sura_with_frequency\n\n\ncheck_sura_with_frequency(sura_num,freq_dec)\n\n- function checks if frequency dictionary of \nspecific chapter\n is compatible with \noriginal chapter\n in quran, it takes \nsura_num\n (chapter number) and \nfreq_dec\n (frequency dictionary) and return \nTrue\n if compatible and \nFalse\n in not.\n\n\n  dictionaryFrequency = pq.generate_frequency_dictionary(111)\n  matched = pq.check_sura_with_frequency(110,dictionaryFrequency)\n  print(matched)\n\n  \n False\n\n\n\n\ngenerate_latex_table\n\n\ngenerate_latex_table(dictionary,filename,location=\".\")\n\n- generates latex code of table of frequency it takes dictionary frequency ,it takes \ndictionary\n (frequency dictionary) , \nfilename\n and \nlocation\n (location to save) , the default location is same directory by symbol '.', then it returns \nTrue\n if the operation of generation completed successfully \nFalse\n if something wrong \n\n\n  latexTable = pq.generate_latex_table(dictionaryFrequency,'any_file_name')\n  print(latexTable)\n\n  \n True\n\n\n\n\nSearch functions\n\n\nsearch_sequence\n\n\nsearch_sequence(sequancesList,verse=None,chapterNum=0,verseNum=0,mode=3)\n\n- take list of sequances and return matched sequance, it search in verse ot chapter or All Quran,\n    - it return for every match :\n         - matched sequance \n         - chapter number of occurrence\n         - token number if word and 0 if sentence\n\n\n- Note :\n     - if found verse != None it will use it en search .    \n     - if no verse and found chapterNum and verseNum it will use this verse and use it to search.\n     - if no verse and no verseNum and found chapterNum it will search in chapter.\n     - if no verse and no chapterNum and no verseNum it will search in All Quran.\n\n- it has many modes:\n    1. search with decorated sequance (with tashkeel), and return matched sequance with decorates (with tashkil).\n    2. search without decorated sequance (without tashkeel), and return matched sequance without decorates (without tashkil).\n    3. search without decorated sequance (without tashkeel), and return matched sequance with decorates (with tashkil).\n\n\n- optional opptions: \n    - **verse** (str): if passed, it will applied to this string only \n    - **chapterNum** (int) : if passed only, it will applied to this chapter only.\n    - **verseNum** (int) :\n        - if passed only, it will applied to **verseNum** for **all Chapters**.\n        - if passed with **chapterNum**, it will applied to verseNum for **chapterNum**.\n    - **with_tashkeel** (bool):\n        - if **True** applied to Quran **with** Tashkieel.\n        - if **False** applied to Quran **without** Tashkieel.\n        - mode (int): this mode that you need to use and default mode 3\n\n- Note : if don't pass any  **optional opptions** it will applied to all **Quran**.\n- Returns: dict() : key is sequances and value is a list of matched_sequance and their positions\n\n\n\n  matchedKeyword = pq.search_sequence(['\u0642\u0644 \u0623\u0639\u0648\u0630 \u0628\u0631\u0628'])\n  print(matchedKeyword)\n\n  \n {'\u0642\u0644 \u0623\u0639\u0648\u0630 \u0628\u0631\u0628': [('\u0642\u064f\u0644\u0652 \u0623\u064e\u0639\u064f\u0648\u0630\u064f \u0628\u0650\u0631\u064e\u0628\u0651\u0650', 0, 1, 113), ('\u0642\u064f\u0644\u0652 \u0623\u064e\u0639\u064f\u0648\u0630\u064f \u0628\u0650\u0631\u064e\u0628\u0651\u0650', 0, 1, 114)]}\n\n\n\n\n\nsearch_string_with_tashkeel\n\n\nsearch_string_with_tashkeel(sentence,tashkeel_pattern)\n\n- takes an \nsentence\n and \ntashkeel_pattern\n (composed of 0's , 1's) and it returns the locations that matched the pattern of diacrictics start index \ninclusive\n and end index \nexculsive\n and return empty list if not found.\n\n\n\n  sentence = '\u0635\u0650\u0641\u0652 \u0630\u064e\u0627\u0652 \u062b\u064e\u0646\u064e\u0627\u0652 \u0643\u064e\u0645\u0652 \u062c\u064e\u0627\u0652\u062f\u064e \u0634\u064e\u062e\u0652\u0635\u064c'\n  tashkeel_pattern = ar.fatha + ar.sukun\n  results = pq.search_string_with_tashkeel(sentence,tashkeel_pattern)\n  print(results)\n\n  \n [(3, 5), (7, 9), (10, 12), (13, 15), (17, 19)]\n\n\n\n\nsearch_with_pattern\n\n\nsearch_with_pattern(pattern,sentence=None,verseNum=None,chapterNum=None,threshold=1)\n\n- this function use to search in 0's,1's pattern and return matched words from sentence pattern dependent on the    threshold, it takes a \npatter\n that you need to looking for , and \nsentence (optional)\n (sentence where will   search), \nchapterNum (opetional)\n and \nverseNum (opetional)\n and return list of matched words and sentences. \n\n\n- Cases: \n    1. if pass sentece only or with another args \n       it will search in sentece only.\n    2. if not passed sentence and passed verseNum and chapterNum,\n       it will search in this verseNum that exist in chapterNum only.\n    3. if not passed sentence,verseNum and passed chapterNum only,\n       it will search in this specific chapter only\n\n  * Note : it's takes time dependent on your threshold and size of chapter, so it's not support to search on All-Quran becouse it take very long time more than 11 min.\n\n\n\n\n  result = pq.search_with_pattern(pattern=\n01111\n,chapterNum=1,threshold=0.9)\n  print(result)\n\n  \n['\u0627\u0644\u0631\u0651\u064e\u062d\u0650\u064a\u0645\u0650 \u0645\u064e\u0644\u0650\u0643\u0650', '\u0646\u064e\u0639\u0652\u0628\u064f\u062f\u064f \u0648\u064e\u0625\u0650\u064a\u0651\u064e\u0627\u0643\u064e', '\u0627\u0644\u0652\u0645\u064f\u0633\u0652\u062a\u064e\u0642\u0650\u064a\u0645\u064e \u0635\u0650\u0631\u064e\u0637\u064e']", 
            "title": "Documentation"
        }, 
        {
            "location": "/DOCUMENTATION/#documentation", 
            "text": "Features  Imporatan information  Usage  Functions  Access functions  get_sura  get_verse  get_token  get_sura_number  get_sura_name  get_verse_count    Manipulate functions  separate_token_with_diacritics  get_tashkeel_binary  unpack_alef_mad  shape  check_system  check_all_alphabet  buckwalter_transliteration  extract_tashkeel    Analysis functions  count_shape  count_token  frequency_of_character    generate_frequancy_dictionary  sort_dictionary_by_similarity  check_sura_with_frequency  generate_latex_table    Search functions  search_sequence  search_string_with_tashkeel  search_with_pattern", 
            "title": "Documentation"
        }, 
        {
            "location": "/DOCUMENTATION/#features", 
            "text": "Access Holy-Quran :  get  Chapter  with/without diacritics.  get  Verse  with/without diacritics.  get  Token  (word).  get  Chapter name  ,  Chapter number .  get  Verses number  in verse.    Manipulate with Holy-Quran :  Separate to  letters  with/without diacritics.  Apply your  System  on Quran.  get  Binary representation  of Holy-Quran as 0's , 1's.  Extract  Taskill  from sentence.   Dealing with linguistic rules like :  Transfer Alef-mad  \"\u0622\"  to \"\u0623\u064e\u0623\u0652\"     Convert the  unicode of arabic  text to  buckwalter encoding  and vice versa  Convert Quran to  buckwalter reprsentation  and vice versa.     Analysis Holy-Quran:  get  Frequency Matrix  of letters dependent on Applied  alphabet system .  get  Frequency dictionary  of tokens.  sort  Frequency dictionary  using similarity threshold.    Search in Holy-Quran using :  Text  and ther is a variety options.  diacritics pattern .   binary representation pattern  using threshold.", 
            "title": "Features"
        }, 
        {
            "location": "/DOCUMENTATION/#imporatan-information", 
            "text": "Note all verses/chapters/tokens start with  1  not  0", 
            "title": "Imporatan information"
        }, 
        {
            "location": "/DOCUMENTATION/#alphasystem", 
            "text": "it's collection of Alphabits that you can apply it on Quran as you need, where you can treat many characters as one character, like:  system = [['\u0623','\u0622','\u0625'],['\u062a','\u0628']]  here we treat  ['\u0623','\u0622','\u0625']  as one character and  ['\u062a','\u0628']  as another one and the  res characters  every one treat as one, this system applied to all functions in  PyQuran  in Counting,Search,Filltering ...etc.   the default system used in library treat every character as one , you will find some of  pre-defined  parts of system that you can use it to define your system , import  systems  to use them.   pre-defined:  withoutDotSystem (treat all characters has dot as one)  hamazatSystem (treat all characters has hamza as one)     from pyquran import systems\nsystem = [['\u062a','\u0628'], systems.hamazatSystem]", 
            "title": "AlphaSystem :"
        }, 
        {
            "location": "/DOCUMENTATION/#usage", 
            "text": "import PyQuran as pq", 
            "title": "Usage"
        }, 
        {
            "location": "/DOCUMENTATION/#functions", 
            "text": "", 
            "title": "Functions"
        }, 
        {
            "location": "/DOCUMENTATION/#access-functions", 
            "text": "", 
            "title": "Access functions:"
        }, 
        {
            "location": "/DOCUMENTATION/#get_sura", 
            "text": "get_sura(chapter_num,with_tashkeil) \n- takes  chapter_num  it's the number of surah and returns  list of chapter verses  and the  with_tashkeil (optional)  is the diacritics option and if  True  return chapter with diacritics and if  False  return without and defualt  false  .    sura = pq.get_sura(108,True)\n  print(sura)\n\n    ['\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e', '\u0641\u064e\u0635\u064e\u0644\u0651\u0650 \u0644\u0650\u0631\u064e\u0628\u0651\u0650\u0643\u064e \u0648\u064e\u0627\u0646\u0652\u062d\u064e\u0631\u0652', '\u0625\u0650\u0646\u0651\u064e \u0634\u064e\u0627\u0646\u0650\u0626\u064e\u0643\u064e \u0647\u064f\u0648\u064e \u0627\u0644\u0652\u0623\u064e\u0628\u0652\u062a\u064e\u0631\u064f']", 
            "title": "get_sura"
        }, 
        {
            "location": "/DOCUMENTATION/#get_verse", 
            "text": "get_verse(chapter_num,verse_num,with_tashkeel)  \n- takes the  chapter_num  ,  verse_num  and and it return  verse content  and  with_tashkeil (optional)  is the diacritics option and if  True  return verses with diacritics and if  False  return without and defualt  false .    ayahText=pq.get_verse(110,1,True)\n  print(ayahText)\n\n    \u0625\u0650\u0630\u064e\u0627 \u062c\u064e\u0627\u0621\u064e \u0646\u064e\u0635\u0652\u0631\u064f \u0627\u0644\u0644\u0651\u064e\u0647\u0650 \u0648\u064e\u0627\u0644\u0652\u0641\u064e\u062a\u0652\u062d\u064f", 
            "title": "get_verse"
        }, 
        {
            "location": "/DOCUMENTATION/#get_token", 
            "text": "get_token(token_num , verse_num , chapter_num , with_tashkeel)  \n- takes the  token_num  (position Of Token) ,  verse_num  ,  chapter_num  and it return  token   and  with_tashkeil (optional)  is the diacritics option and if  True  return token with diacritics and if  False  return without and defualt  false  .    tokenText = pq.get_token(4,1,114,True)\n  print(tokenText)\n\n    \u0627\u0644\u0646\u0651\u064e\u0627\u0633\u0650", 
            "title": "get_token"
        }, 
        {
            "location": "/DOCUMENTATION/#get_sura_number", 
            "text": "get_sura_number(chapter_name) \n- takes the name of chapter and return it's number.    suraNumber = pq.get_sura_number('\u0627\u0644\u0645\u0644\u0643')\n  print(suraNumber)\n\n    67", 
            "title": "get_sura_number"
        }, 
        {
            "location": "/DOCUMENTATION/#get_sura_name", 
            "text": "get_sura_name(chapter_num)  \n- takes the number of chapter and return it's.    suraName = pq.get_sura_name(67)\n  print(suraName)\n\n    \u0627\u0644\u0645\u0644\u0643", 
            "title": "get_sura_name"
        }, 
        {
            "location": "/DOCUMENTATION/#get_verse_count", 
            "text": "get_verse_count(chapter) \n- takes  chapter  and return the number of verses.    numberOfAyat = pd.get_verse_count(pq.get_sura(110,True))\n  print(numberOfAyat)\n\n    3", 
            "title": "get_verse_count"
        }, 
        {
            "location": "/DOCUMENTATION/#manipulate-functions", 
            "text": "", 
            "title": "Manipulate functions:"
        }, 
        {
            "location": "/DOCUMENTATION/#separate_token_with_diacritics", 
            "text": "separate_token_with_diacritics(sentence) \n- takes  sentence  and separate it to characters with there diacritics.    wordSeparated = pq.separate_token_with_dicrites('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\n  print(wordSeparated)\n\n    ['\u0625\u0650', '\u0646\u0651\u064e', '\u0627', ' ', '\u0623\u064e', '\u0639\u0652', '\u0637\u064e', '\u064a\u0652', '\u0646\u064e', '\u0643\u064e', ' ', '\u0627', '\u0644\u0652', '\u0643\u064e', '\u0648\u0652', '\u062b\u064e', '\u0631\u064e']", 
            "title": "separate_token_with_diacritics"
        }, 
        {
            "location": "/DOCUMENTATION/#get_tashkeel_binary", 
            "text": "get_tashkeel_binary(verse) \n- takes the verses content or chapters with diacritics and it returns tuple of the mapping of  chracters with diacritics  to  0's,1's  and  harakah  represented as  1  and  sukun  represented as  0  and return list of diacritics too.    pattern = pq.get_tashkeel_binary('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\n  print(pattern)\n\n    ('1010 101011 001011', ['\u0650', '\u0652', '\u064e', '', '', '\u064e', '\u0652', '\u064e', '\u0652', '\u064e', '\u064e', '', '', '\u0652', '\u064e', '\u0652', '\u064e', '\u064e'])", 
            "title": "get_tashkeel_binary"
        }, 
        {
            "location": "/DOCUMENTATION/#unpack_alef_mad", 
            "text": "unpack_alef_mad(ayahWithAlefMad) \n- takes  ayahWithAlefMad  (sentence that has Alef-Mad) and it returns the sentence after replace  Alef-mad  to  Alef-hamza-above + fatha  and  alef-hamza-above + sukun .    unpackAlefMad = pq.unpack_alef_mad('\u0622')\n  print(unpackAlefMad)\n\n    '\u0623\u0652\u0623\u064e'", 
            "title": "unpack_alef_mad"
        }, 
        {
            "location": "/DOCUMENTATION/#shape", 
            "text": "shape(system) \n- takes  system  (a new system for alphabets) ,system is \" a list of lists \" that want to treat every \" inner list \" as one character and returns a dictionary has the same value for each set of alphabets and diffirent values for the rest of alphabets , you can see to more details  here .    newSystem = [[pq.beh, pq.teh], [pq.jeem, pq.hah, pq.khah]]\n  updatedSystem = pq.shape(newSystem)\n  print(updatedSystem)\n\n    {'\u0628': 0, '\u062a': 0, '\u062b': 0, '\u062c': 1, '\u062d': 1, '\u062e': 1, '\u0621': 2, '\u0622': 3, '\u0623': 4, '\u0624': 5, '\u0625': 6, '\u0626': 7, '\u0627': 8, '\u0629': 9, '\u062f': 10, '\u0630': 11, '\u0631': 12, '\u0632': 13, '\u0633': 14, '\u0634': 15, '\u0635': 16, '\u0636': 17, '\u0637': 18, '\u0638': 19, '\u0639': 20, '\u063a': 21, '\u0641': 22, '\u0642': 23, '\u0643': 24, '\u0644': 25, '\u0645': 26, '\u0646': 27, '\u0647': 28, '\u0648': 29, '\u0649': 30, '\u064a': 31, ' ': 70}", 
            "title": "shape"
        }, 
        {
            "location": "/DOCUMENTATION/#check_all_alphabet", 
            "text": "check_all_alphabet(system) \n- takes  system  and return the rest of default alphabet chracters that doesn't include  system .    system = [[pq.beh, pq.teh], [pq.jeem, pq.hah, pq.khah]]\n  rest = pq.check_all_alphabet(system)\n  print(rest)\n\n    ['\u0621', '\u0622', '\u0623', '\u0624', '\u0625', '\u0626', '\u0627', '\u0629', '\u062b', '\u062f', '\u0630', '\u0631', '\u0632', '\u0633', '\u0634', '\u0635', '\u0636', '\u0637', '\u0638', '\u0639', '\u063a', '\u0641', '\u0642', '\u0643', '\u0644', '\u0645', '\u0646', '\u0647', '\u0648', '\u0649', '\u064a']", 
            "title": "check_all_alphabet"
        }, 
        {
            "location": "/DOCUMENTATION/#check_system", 
            "text": "def check_system(system, indx=None) \n- takes  system  and return main system after apply new system and takes too  index (optional)  that return specific collection from main system.      # without index\n  system = [[pq.beh, pq.teh], [pq.jeem, pq.hah, pq.khah]]\n  rest = pq.check_system(system)\n  print(rest)\n\n    [['\u0628', '\u062a'], ['\u062c', '\u062d', '\u062e'], ['\u0621'], ['\u0622'], ['\u0623'], ['\u0624'], ['\u0625'], ['\u0626'], ['\u0627'], ['\u0629'], ['\u062b'], ['\u062f'], ['\u0630'], ['\u0631'], ['\u0632'], ['\u0633'], ['\u0634'], ['\u0635'], ['\u0636'], ['\u0637'], ['\u0638'], ['\u0639'], ['\u063a'], ['\u0641'], ['\u0642'], ['\u0643'], ['\u0644'], ['\u0645'], ['\u0646'], ['\u0647'], ['\u0648'], ['\u0649'], ['\u064a']]\n\n\n  # with index\n  system = [[pq.beh, pq.teh], [pq.jeem, pq.hah, pq.khah]]\n  rest = pq.check_system(system,index=1)\n  print(rest)\n\n    ['\u062c', '\u062d', '\u062e']\n ```\n\n\n#### buckwalter_transliteration\n**buckwalter_transliteration(sentence, reverse)**\n- takes an **sentence** and **reverse (optional)** the trnslate option if **True** convert **sentence** from Arabic to BuckWalter and if **False (default)** convert **sentence** from BuckWalter to Arabic.\n\n##### note**:the encoding with **diacritics** is  different from **without diacritics**.\n\n```python\n  buckwalterEncode = pq.buckwalter_transliteration('\u0625\u0650\u0646\u0651\u064e\u0627 \u0623\u064e\u0639\u0652\u0637\u064e\u064a\u0652\u0646\u064e\u0643\u064e \u0627\u0644\u0652\u0643\u064e\u0648\u0652\u062b\u064e\u0631\u064e')\n  print(buckwalterEncode)\n\n     in~aA  aEoTayonaka Alokawovara", 
            "title": "check_system"
        }, 
        {
            "location": "/DOCUMENTATION/#extract_tashkeel", 
            "text": "extract_tashkeel(sentence) \n- takes an  sentence  and return the tashleel only without charaters. Comming soooooon =D .....Taha Magedy Note", 
            "title": "extract_tashkeel"
        }, 
        {
            "location": "/DOCUMENTATION/#analysis-functions", 
            "text": "", 
            "title": "Analysis functions:"
        }, 
        {
            "location": "/DOCUMENTATION/#count_shape", 
            "text": "count_shape(text, system=None) \n- takes  text  (chapter/verse),  system (optional)  it's the shape of character as example [[bah,gem]] and return a  n*p matrix  where  n  number of verses and  p  number of collections in system and if not pass system it will apply the defualt.      newSystem=[[beh, teh, theh], [jeem, hah, khah]]\n  alphabetAsOneShape =pq.count_shape(get_sura(110), newSystem)\n  print(alphabetAsOneShape)\n\n    [[1 2 1 0 0 0 1 0 4 0 0 1 1 0 0 0 1 0 0 0 0 0 1 0 0 3 0 1 1 1 0 0]\n       [1 2 0 0 2 0 0 0 5 0 2 0 1 0 1 0 0 0 0 0 0 0 2 0 0 4 0 3 1 3 1 3]\n       [6 2 0 0 0 0 1 0 4 0 1 0 2 0 2 0 0 0 0 0 0 1 2 0 2 0 1 2 2 2 0 0]]", 
            "title": "count_shape"
        }, 
        {
            "location": "/DOCUMENTATION/#count_token", 
            "text": "count_token(text)  \n- takes  text  (chapter/verse) and returns the number of tokens.", 
            "title": "count_token"
        }, 
        {
            "location": "/DOCUMENTATION/#note-the-harf-is-not-calculated-as-token-alone", 
            "text": "numberOfToken=pq.count_token(tools.get_sura(110))\n  print(numberOfToken)\n\n    19", 
            "title": "note: the harf ('\u0648') is not calculated as token alone"
        }, 
        {
            "location": "/DOCUMENTATION/#frequency_of_character", 
            "text": "frequency_of_character(characters,verse=None,chapterNum=0,verseNum=0,with_tashkeel=False) \n- takes  characters  that you need to count , return dictionary that havecounts characters occurrence for verses or with chapter or even all quran and the dictionary contains the key char and values is an occurrence of character .\n- optional opptions: \n    -  verse  (str): if passed, it will applied to this string only \n    -  chapterNum  (int) : if passed only, it will applied to this chapter only.\n    -  verseNum  (int) :\n        - if passed only, it will applied to  verseNum  for  all Chapters .\n        - if passed with  chapterNum , it will applied to verseNum for  chapterNum .\n    -  with_tashkeel  (bool):\n        - if  True  applied to Quran  with  Tashkieel.\n        - if  False  applied to Quran  without  Tashkieel.\n- Note : if don't pass any   optional opptions  it will applied to all  Quran .    frequencyOfChar =tools.frequency_of_character(['\u0623','\u0628'],'\u0642\u0644 \u0623\u0639\u0648\u0630 \u0628\u0631\u0628 \u0627\u0644\u0646\u0627\u0633',114,1)\n  print(frequencyOfChar)\n\n    {\u0623:1,\u0628:2}", 
            "title": "frequency_of_character"
        }, 
        {
            "location": "/DOCUMENTATION/#generate_frequancy_dictionary", 
            "text": "generate_frequency_dictionary(suraNumber=None)  \n- takes  suraNumber (optional)  the number of chapter and it returns the dictionary of  words contains the  word  as key and its  frequency  as value and if not pass  suraNumber  it will applied to  all-Quran .    dictionaryFrequency = pq.generate_frequency_dictionary(114)\n  print(dictionaryFrequency)\n\n    {'\u0627\u0644\u0646\u0627\u0633': 4, '\u0645\u0646': 2, '\u0642\u0644': 1, '\u0623\u0639\u0648\u0630': 1, '\u0628\u0631\u0628': 1, '\u0645\u0644\u0643': 1, '\u0625\u0644\u0647': 1, '\u0634\u0631': 1, '\u0627\u0644\u0648\u0633\u0648\u0627\u0633': 1, '\u0627\u0644\u062e\u0646\u0627\u0633': 1, '\u0627\u0644\u0630\u0649': 1, '\u064a\u0648\u0633\u0648\u0633': 1, '\u0641\u0649': 1, '\u0635\u062f\u0648\u0631': 1, '\u0627\u0644\u062c\u0646\u0629': 1, '\u0648\u0627\u0644\u0646\u0627\u0633': 1}", 
            "title": "generate_frequancy_dictionary"
        }, 
        {
            "location": "/DOCUMENTATION/#sort_dictionary_by_similarity", 
            "text": "sort_dictionary_by_similarity(frequency_dictionary,threshold=0.8) \n- using to  cluster words  by using similarity  and sort every bunch of word  by most common and sort bunches descending in the same time takes the frequency dictionary generated using  generate_frequency_dictionary  function. This function takes dictionary of frequencies and  threshold (optional)  to specify  the degree of similarity      sortedDictionary = pq.sort_dictionary_by_similarity(dictionaryFrequency)\n  print(sortedDictionary)\n\n    {'\u0627\u0644\u0646\u0627\u0633': 4, '\u0627\u0644\u062e\u0646\u0627\u0633': 1, '\u0648\u0627\u0644\u0646\u0627\u0633': 1, '\u0645\u0646': 2, '\u0642\u0644': 1, '\u0623\u0639\u0648\u0630': 1, '\u0628\u0631\u0628': 1, '\u0645\u0644\u0643': 1, '\u0625\u0644\u0647': 1, '\u0634\u0631': 1, '\u0627\u0644\u0648\u0633\u0648\u0627\u0633': 1, '\u0627\u0644\u0630\u0649': 1, '\u064a\u0648\u0633\u0648\u0633': 1, '\u0641\u0649': 1, '\u0635\u062f\u0648\u0631': 1, '\u0627\u0644\u062c\u0646\u0629': 1}", 
            "title": "sort_dictionary_by_similarity"
        }, 
        {
            "location": "/DOCUMENTATION/#check_sura_with_frequency", 
            "text": "check_sura_with_frequency(sura_num,freq_dec) \n- function checks if frequency dictionary of  specific chapter  is compatible with  original chapter  in quran, it takes  sura_num  (chapter number) and  freq_dec  (frequency dictionary) and return  True  if compatible and  False  in not.    dictionaryFrequency = pq.generate_frequency_dictionary(111)\n  matched = pq.check_sura_with_frequency(110,dictionaryFrequency)\n  print(matched)\n\n    False", 
            "title": "check_sura_with_frequency"
        }, 
        {
            "location": "/DOCUMENTATION/#generate_latex_table", 
            "text": "generate_latex_table(dictionary,filename,location=\".\") \n- generates latex code of table of frequency it takes dictionary frequency ,it takes  dictionary  (frequency dictionary) ,  filename  and  location  (location to save) , the default location is same directory by symbol '.', then it returns  True  if the operation of generation completed successfully  False  if something wrong     latexTable = pq.generate_latex_table(dictionaryFrequency,'any_file_name')\n  print(latexTable)\n\n    True", 
            "title": "generate_latex_table"
        }, 
        {
            "location": "/DOCUMENTATION/#search-functions", 
            "text": "", 
            "title": "Search functions"
        }, 
        {
            "location": "/DOCUMENTATION/#search_sequence", 
            "text": "search_sequence(sequancesList,verse=None,chapterNum=0,verseNum=0,mode=3) \n- take list of sequances and return matched sequance, it search in verse ot chapter or All Quran,\n    - it return for every match :\n         - matched sequance \n         - chapter number of occurrence\n         - token number if word and 0 if sentence  - Note :\n     - if found verse != None it will use it en search .    \n     - if no verse and found chapterNum and verseNum it will use this verse and use it to search.\n     - if no verse and no verseNum and found chapterNum it will search in chapter.\n     - if no verse and no chapterNum and no verseNum it will search in All Quran.\n\n- it has many modes:\n    1. search with decorated sequance (with tashkeel), and return matched sequance with decorates (with tashkil).\n    2. search without decorated sequance (without tashkeel), and return matched sequance without decorates (without tashkil).\n    3. search without decorated sequance (without tashkeel), and return matched sequance with decorates (with tashkil).\n\n\n- optional opptions: \n    - **verse** (str): if passed, it will applied to this string only \n    - **chapterNum** (int) : if passed only, it will applied to this chapter only.\n    - **verseNum** (int) :\n        - if passed only, it will applied to **verseNum** for **all Chapters**.\n        - if passed with **chapterNum**, it will applied to verseNum for **chapterNum**.\n    - **with_tashkeel** (bool):\n        - if **True** applied to Quran **with** Tashkieel.\n        - if **False** applied to Quran **without** Tashkieel.\n        - mode (int): this mode that you need to use and default mode 3\n\n- Note : if don't pass any  **optional opptions** it will applied to all **Quran**.\n- Returns: dict() : key is sequances and value is a list of matched_sequance and their positions    matchedKeyword = pq.search_sequence(['\u0642\u0644 \u0623\u0639\u0648\u0630 \u0628\u0631\u0628'])\n  print(matchedKeyword)\n\n    {'\u0642\u0644 \u0623\u0639\u0648\u0630 \u0628\u0631\u0628': [('\u0642\u064f\u0644\u0652 \u0623\u064e\u0639\u064f\u0648\u0630\u064f \u0628\u0650\u0631\u064e\u0628\u0651\u0650', 0, 1, 113), ('\u0642\u064f\u0644\u0652 \u0623\u064e\u0639\u064f\u0648\u0630\u064f \u0628\u0650\u0631\u064e\u0628\u0651\u0650', 0, 1, 114)]}", 
            "title": "search_sequence"
        }, 
        {
            "location": "/DOCUMENTATION/#search_string_with_tashkeel", 
            "text": "search_string_with_tashkeel(sentence,tashkeel_pattern) \n- takes an  sentence  and  tashkeel_pattern  (composed of 0's , 1's) and it returns the locations that matched the pattern of diacrictics start index  inclusive  and end index  exculsive  and return empty list if not found.  \n  sentence = '\u0635\u0650\u0641\u0652 \u0630\u064e\u0627\u0652 \u062b\u064e\u0646\u064e\u0627\u0652 \u0643\u064e\u0645\u0652 \u062c\u064e\u0627\u0652\u062f\u064e \u0634\u064e\u062e\u0652\u0635\u064c'\n  tashkeel_pattern = ar.fatha + ar.sukun\n  results = pq.search_string_with_tashkeel(sentence,tashkeel_pattern)\n  print(results)\n\n    [(3, 5), (7, 9), (10, 12), (13, 15), (17, 19)]", 
            "title": "search_string_with_tashkeel"
        }, 
        {
            "location": "/DOCUMENTATION/#search_with_pattern", 
            "text": "search_with_pattern(pattern,sentence=None,verseNum=None,chapterNum=None,threshold=1) \n- this function use to search in 0's,1's pattern and return matched words from sentence pattern dependent on the    threshold, it takes a  patter  that you need to looking for , and  sentence (optional)  (sentence where will   search),  chapterNum (opetional)  and  verseNum (opetional)  and return list of matched words and sentences.   - Cases: \n    1. if pass sentece only or with another args \n       it will search in sentece only.\n    2. if not passed sentence and passed verseNum and chapterNum,\n       it will search in this verseNum that exist in chapterNum only.\n    3. if not passed sentence,verseNum and passed chapterNum only,\n       it will search in this specific chapter only\n\n  * Note : it's takes time dependent on your threshold and size of chapter, so it's not support to search on All-Quran becouse it take very long time more than 11 min.  \n  result = pq.search_with_pattern(pattern= 01111 ,chapterNum=1,threshold=0.9)\n  print(result)\n\n   ['\u0627\u0644\u0631\u0651\u064e\u062d\u0650\u064a\u0645\u0650 \u0645\u064e\u0644\u0650\u0643\u0650', '\u0646\u064e\u0639\u0652\u0628\u064f\u062f\u064f \u0648\u064e\u0625\u0650\u064a\u0651\u064e\u0627\u0643\u064e', '\u0627\u0644\u0652\u0645\u064f\u0633\u0652\u062a\u064e\u0642\u0650\u064a\u0645\u064e \u0635\u0650\u0631\u064e\u0637\u064e']", 
            "title": "search_with_pattern"
        }, 
        {
            "location": "/FAQ/", 
            "text": "Hello!", 
            "title": "FAQ"
        }, 
        {
            "location": "/Filtering-Special-Recitation-Symbols/", 
            "text": "Quran Corpus\n\n\nAs it is mentioned in \nREADME\n\nwe use the \nUthmani Text\n of Quran from \ntanzil\n.\n\nThis is the its hashing \nMD5 (quran-uthmani.xml) = 6aae945d556a1b28cfe682c0ea5ab518\n.\n\n\nQuran is an Arabic book, which is written is Arabic Alphabet, but the \nQuran scholars\n have put\nsome marks to help reciters and readers in pronouncing and give them some guidance like the kind of \nsome letters and pause marks.\n\n\nThose are the unique characters in the corpus.\n\n((Table Unicode | Symbol  | Kind {letter/mark}))\n\n\nFiltering Recitation Symbols\n\n\nWhile fetching fetching from corpus, we run the following method to remove all\nthe recitation marks\u2014\nthey are NOT letters\n\u2014.\n\n\nThe only thing we replace, is the Alef wasl: \u0671, we add Alef: \u0627 instead, because alef wasl and alef are the same\none letter in Arabic, but alef wasl has a mark above it to indicate that it is not pronounced\nas a glottal stop in case of continuing, \nRead more about Alef Wasl\n.\n\n\nThis filtering is done in run time, we of course \ndo not\n change the corpus at all.\n\n\nThe functions code does filtering:\n\n\ndef recitation_symbols_filter(string, symbols=recitationSymbols ):\n    '''Removes the Special Recitation Symbols from `string`\n    \u00a6   Args:\n    \u00a6   \u00a6   param1(str): a string to be filtered\n    \u00a6   \u00a6   param2([char]): a list of recitation symbols\n    '''\n    for symbol in symbols:\n    \u00a6   if symbol == alef_wasl_with_saad_above:\n    \u00a6   \u00a6   string = string.replace(alef_wasl_with_saad_above, arabic.alef)\n    \u00a6   else:\n    \u00a6   \u00a6   string = string.replace(symbol, '')\n\n    return string\n\n\n\n\n\n\nAlso feel free to report any bug or lingual error, you are most welcome, just fire an issue.", 
            "title": "Quran Corpus"
        }, 
        {
            "location": "/Filtering-Special-Recitation-Symbols/#quran-corpus", 
            "text": "As it is mentioned in  README \nwe use the  Uthmani Text  of Quran from  tanzil . \nThis is the its hashing  MD5 (quran-uthmani.xml) = 6aae945d556a1b28cfe682c0ea5ab518 .  Quran is an Arabic book, which is written is Arabic Alphabet, but the  Quran scholars  have put\nsome marks to help reciters and readers in pronouncing and give them some guidance like the kind of \nsome letters and pause marks.  Those are the unique characters in the corpus. \n((Table Unicode | Symbol  | Kind {letter/mark}))", 
            "title": "Quran Corpus"
        }, 
        {
            "location": "/Filtering-Special-Recitation-Symbols/#filtering-recitation-symbols", 
            "text": "While fetching fetching from corpus, we run the following method to remove all\nthe recitation marks\u2014 they are NOT letters \u2014.  The only thing we replace, is the Alef wasl: \u0671, we add Alef: \u0627 instead, because alef wasl and alef are the same\none letter in Arabic, but alef wasl has a mark above it to indicate that it is not pronounced\nas a glottal stop in case of continuing,  Read more about Alef Wasl .  This filtering is done in run time, we of course  do not  change the corpus at all.  The functions code does filtering:  def recitation_symbols_filter(string, symbols=recitationSymbols ):\n    '''Removes the Special Recitation Symbols from `string`\n    \u00a6   Args:\n    \u00a6   \u00a6   param1(str): a string to be filtered\n    \u00a6   \u00a6   param2([char]): a list of recitation symbols\n    '''\n    for symbol in symbols:\n    \u00a6   if symbol == alef_wasl_with_saad_above:\n    \u00a6   \u00a6   string = string.replace(alef_wasl_with_saad_above, arabic.alef)\n    \u00a6   else:\n    \u00a6   \u00a6   string = string.replace(symbol, '')\n\n    return string   Also feel free to report any bug or lingual error, you are most welcome, just fire an issue.", 
            "title": "Filtering Recitation Symbols"
        }, 
        {
            "location": "/Home/", 
            "text": "FAQ\n \u2014 answers to frequently asked questions\n\n\n\n\nDocumentation\n\n\nThis is suitable for the \nPyQuran\n users.\n\n\nDevelopment\n\n\nThis section is for \nPyQuran\n maintainers.\n\n\n\n\n\n\nProject Structure\n\n\nPyQuran\n is organized as the following:\n\n\ncore\n: contains main functions/modules.\n\n\ntools\n: contains helper functions/modules.\n\n\ntesting\n: contains unit tests for each module.\n\n\nQuranCorpus\n: contains Quran corpus and corpus hashes.\n\n\n\n\n.\n\u2502   README.md\n\u2502   setup.py\n|   __init__.py\n|       ...\n|\n\u2514\u2500\u2500\u2500core\n\u2502   \u2502   pyquran.py\n\u2502   \u2502      ...   \n|\n\u2514\u2500\u2500\u2500tools\n|   \u2502   filtering.py\n|   |      ...\n\u2502   \n\u2514\u2500\u2500\u2500testing\n|   \u2502   test_filtering.py\n|   |      ...\n\u2502   \n\u2514\u2500\u2500\u2500QuranCorpus\n    \u2502   quran-uthmani.xml\n    |      ...", 
            "title": "Home"
        }, 
        {
            "location": "/Home/#documentation", 
            "text": "This is suitable for the  PyQuran  users.", 
            "title": "Documentation"
        }, 
        {
            "location": "/Home/#development", 
            "text": "This section is for  PyQuran  maintainers.", 
            "title": "Development"
        }, 
        {
            "location": "/Home/#project-structure", 
            "text": "PyQuran  is organized as the following:  core : contains main functions/modules.  tools : contains helper functions/modules.  testing : contains unit tests for each module.  QuranCorpus : contains Quran corpus and corpus hashes.   .\n\u2502   README.md\n\u2502   setup.py\n|   __init__.py\n|       ...\n|\n\u2514\u2500\u2500\u2500core\n\u2502   \u2502   pyquran.py\n\u2502   \u2502      ...   \n|\n\u2514\u2500\u2500\u2500tools\n|   \u2502   filtering.py\n|   |      ...\n\u2502   \n\u2514\u2500\u2500\u2500testing\n|   \u2502   test_filtering.py\n|   |      ...\n\u2502   \n\u2514\u2500\u2500\u2500QuranCorpus\n    \u2502   quran-uthmani.xml\n    |      ...", 
            "title": "Project Structure"
        }, 
        {
            "location": "/PyQuran-Founders/", 
            "text": "Graduation Project\n\n\nContacts\n\n\nWaleed A. Yousef, Ph.D.  \nwyousef at fci dot Helwan dot edu dot eg\n\nTaha Magdy: tahamagdy@fci.helwan.edu.eg\n\nUmar Mohammed: umar.ibrahime@fci.helwan.edu.eg", 
            "title": "Graduation Project"
        }, 
        {
            "location": "/PyQuran-Founders/#graduation-project", 
            "text": "", 
            "title": "Graduation Project"
        }, 
        {
            "location": "/PyQuran-Founders/#contacts", 
            "text": "Waleed A. Yousef, Ph.D.   wyousef at fci dot Helwan dot edu dot eg \nTaha Magdy: tahamagdy@fci.helwan.edu.eg \nUmar Mohammed: umar.ibrahime@fci.helwan.edu.eg", 
            "title": "Contacts"
        }, 
        {
            "location": "/Wiki-Home/", 
            "text": "FAQ\n \u2014 answers to frequently asked questions\n\n\n\n\nDocumentation\n\n\nThis is suitable for the \nPyQuran\n users.\n\n\nDevelopment\n\n\nThis section is for \nPyQuran\n maintainers.\n\n\n\n\n\n\nProject Structure\n\n\nPyQuran\n is organized as the following:\n\n\ncore\n: contains main functions/modules.\n\n\ntools\n: contains helper functions/modules.\n\n\ntesting\n: contains unit tests for each module.\n\n\nQuranCorpus\n: contains Quran corpus and corpus hashes.\n\n\n\n\n.\n\u2502   README.md\n\u2502   setup.py\n|   __init__.py\n|       ...\n|\n\u2514\u2500\u2500\u2500core\n\u2502   \u2502   pyquran.py\n\u2502   \u2502      ...   \n|\n\u2514\u2500\u2500\u2500tools\n|   \u2502   filtering.py\n|   |      ...\n\u2502   \n\u2514\u2500\u2500\u2500testing\n|   \u2502   test_filtering.py\n|   |      ...\n\u2502   \n\u2514\u2500\u2500\u2500QuranCorpus\n    \u2502   quran-uthmani.xml\n    |      ...", 
            "title": "Wiki Home"
        }, 
        {
            "location": "/Wiki-Home/#documentation", 
            "text": "This is suitable for the  PyQuran  users.", 
            "title": "Documentation"
        }, 
        {
            "location": "/Wiki-Home/#development", 
            "text": "This section is for  PyQuran  maintainers.", 
            "title": "Development"
        }, 
        {
            "location": "/Wiki-Home/#project-structure", 
            "text": "PyQuran  is organized as the following:  core : contains main functions/modules.  tools : contains helper functions/modules.  testing : contains unit tests for each module.  QuranCorpus : contains Quran corpus and corpus hashes.   .\n\u2502   README.md\n\u2502   setup.py\n|   __init__.py\n|       ...\n|\n\u2514\u2500\u2500\u2500core\n\u2502   \u2502   pyquran.py\n\u2502   \u2502      ...   \n|\n\u2514\u2500\u2500\u2500tools\n|   \u2502   filtering.py\n|   |      ...\n\u2502   \n\u2514\u2500\u2500\u2500testing\n|   \u2502   test_filtering.py\n|   |      ...\n\u2502   \n\u2514\u2500\u2500\u2500QuranCorpus\n    \u2502   quran-uthmani.xml\n    |      ...", 
            "title": "Project Structure"
        }
    ]
}